// Package client provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(req *http.Request, ctx context.Context) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListStorageInterface request
	ListStorageInterface(ctx context.Context) (*http.Response, error)

	// CreateStorageInterface request  with any body
	CreateStorageInterfaceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateStorageInterface(ctx context.Context, body CreateStorageInterfaceJSONRequestBody) (*http.Response, error)

	// DeleteBackupByUuid request
	DeleteBackupByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// GetStorageInterfaceByUuid request  with any body
	GetStorageInterfaceByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	GetStorageInterfaceByUuid(ctx context.Context, uuid string, body GetStorageInterfaceByUuidJSONRequestBody) (*http.Response, error)

	// GetStorageInterfaceStatusByUuid request
	GetStorageInterfaceStatusByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// ListClusterWhitelist request
	ListClusterWhitelist(ctx context.Context, clusterUuid string, params *ListClusterWhitelistParams) (*http.Response, error)

	// CreateClusterWhitelist request  with any body
	CreateClusterWhitelistWithBody(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*http.Response, error)

	CreateClusterWhitelist(ctx context.Context, clusterUuid string, body CreateClusterWhitelistJSONRequestBody) (*http.Response, error)

	// DeleteClusterWhitelist request
	DeleteClusterWhitelist(ctx context.Context, clusterUuid string, uuid string) (*http.Response, error)

	// UpdateClusterWhitelist request  with any body
	UpdateClusterWhitelistWithBody(ctx context.Context, clusterUuid string, uuid string, params *UpdateClusterWhitelistParams, contentType string, body io.Reader) (*http.Response, error)

	UpdateClusterWhitelist(ctx context.Context, clusterUuid string, uuid string, params *UpdateClusterWhitelistParams, body UpdateClusterWhitelistJSONRequestBody) (*http.Response, error)

	// CreateContainerShell request
	CreateContainerShell(ctx context.Context, params *CreateContainerShellParams) (*http.Response, error)

	// ListDatabaseTarget request
	ListDatabaseTarget(ctx context.Context) (*http.Response, error)

	// CreateDatabaseTarget request  with any body
	CreateDatabaseTargetWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateDatabaseTarget(ctx context.Context, body CreateDatabaseTargetJSONRequestBody) (*http.Response, error)

	// ValidateMonitorUserPrivilege request  with any body
	ValidateMonitorUserPrivilegeWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	ValidateMonitorUserPrivilege(ctx context.Context, body ValidateMonitorUserPrivilegeJSONRequestBody) (*http.Response, error)

	// DeleteDatabaseTargetByUuid request
	DeleteDatabaseTargetByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// GetDatabaseTargetByUuid request
	GetDatabaseTargetByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// UpdateDatabaseTargetByUuid request  with any body
	UpdateDatabaseTargetByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateDatabaseTargetByUuid(ctx context.Context, uuid string, body UpdateDatabaseTargetByUuidJSONRequestBody) (*http.Response, error)

	// GetDatetime request
	GetDatetime(ctx context.Context) (*http.Response, error)

	// UpdateDatetime request  with any body
	UpdateDatetimeWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	UpdateDatetime(ctx context.Context, body UpdateDatetimeJSONRequestBody) (*http.Response, error)

	// CreateEvent request  with any body
	CreateEventWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateEvent(ctx context.Context, body CreateEventJSONRequestBody) (*http.Response, error)

	// ListEventPage request
	ListEventPage(ctx context.Context, params *ListEventPageParams) (*http.Response, error)

	// ListNetwork request
	ListNetwork(ctx context.Context) (*http.Response, error)

	// CreateNetwork request  with any body
	CreateNetworkWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateNetwork(ctx context.Context, body CreateNetworkJSONRequestBody) (*http.Response, error)

	// DeleleNetworkAddressByUuid request
	DeleleNetworkAddressByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// DeleteNewtorkByUuid request
	DeleteNewtorkByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// CreateNetworkAddress request  with any body
	CreateNetworkAddressWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	CreateNetworkAddress(ctx context.Context, uuid string, body CreateNetworkAddressJSONRequestBody) (*http.Response, error)

	// CreateVIPValiation request
	CreateVIPValiation(ctx context.Context, ip string) (*http.Response, error)

	// GetK8sResourceOverview request
	GetK8sResourceOverview(ctx context.Context) (*http.Response, error)

	// GetLicense request
	GetLicense(ctx context.Context, params *GetLicenseParams) (*http.Response, error)

	// UpdateLicense request  with any body
	UpdateLicenseWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	UpdateLicense(ctx context.Context, body UpdateLicenseJSONRequestBody) (*http.Response, error)

	// LoginUser request  with any body
	LoginUserWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	LoginUser(ctx context.Context, body LoginUserJSONRequestBody) (*http.Response, error)

	// ListMySQLAggregatedSlowQueryLog request
	ListMySQLAggregatedSlowQueryLog(ctx context.Context, params *ListMySQLAggregatedSlowQueryLogParams) (*http.Response, error)

	// ListMySQLErrorLog request
	ListMySQLErrorLog(ctx context.Context, params *ListMySQLErrorLogParams) (*http.Response, error)

	// ListMySQLSlowQueryLog request
	ListMySQLSlowQueryLog(ctx context.Context, params *ListMySQLSlowQueryLogParams) (*http.Response, error)

	// ListMssqlClsuters request
	ListMssqlClsuters(ctx context.Context, params *ListMssqlClsutersParams) (*http.Response, error)

	// CreateMssqlCluster request  with any body
	CreateMssqlClusterWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateMssqlCluster(ctx context.Context, body CreateMssqlClusterJSONRequestBody) (*http.Response, error)

	// ListMssqlSchema request
	ListMssqlSchema(ctx context.Context, clusterUuid string) (*http.Response, error)

	// CreateMssqlSchema request  with any body
	CreateMssqlSchemaWithBody(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*http.Response, error)

	CreateMssqlSchema(ctx context.Context, clusterUuid string, body CreateMssqlSchemaJSONRequestBody) (*http.Response, error)

	// DeleteMssqlSchemaByUuid request
	DeleteMssqlSchemaByUuid(ctx context.Context, clusterUuid string, uuid string) (*http.Response, error)

	// DeleteMssqlClusterByUuid request
	DeleteMssqlClusterByUuid(ctx context.Context, uuid string, params *DeleteMssqlClusterByUuidParams) (*http.Response, error)

	// GetMssqlCluster request
	GetMssqlCluster(ctx context.Context, uuid string) (*http.Response, error)

	// UpdateMssqlClusterByUuid request  with any body
	UpdateMssqlClusterByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateMssqlClusterByUuid(ctx context.Context, uuid string, body UpdateMssqlClusterByUuidJSONRequestBody) (*http.Response, error)

	// ListMysqlCluster request
	ListMysqlCluster(ctx context.Context, params *ListMysqlClusterParams) (*http.Response, error)

	// CreateMysqlCluster request  with any body
	CreateMysqlClusterWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateMysqlCluster(ctx context.Context, body CreateMysqlClusterJSONRequestBody) (*http.Response, error)

	// ListMysqlClusterConfig request
	ListMysqlClusterConfig(ctx context.Context, clusterUuid string) (*http.Response, error)

	// UpdateMysqlClusterConfig request  with any body
	UpdateMysqlClusterConfigWithBody(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateMysqlClusterConfig(ctx context.Context, clusterUuid string, body UpdateMysqlClusterConfigJSONRequestBody) (*http.Response, error)

	// ListMysqlDatabaseSchemas request
	ListMysqlDatabaseSchemas(ctx context.Context, clusterUuid string) (*http.Response, error)

	// CreateMysqlSchema request  with any body
	CreateMysqlSchemaWithBody(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*http.Response, error)

	CreateMysqlSchema(ctx context.Context, clusterUuid string, body CreateMysqlSchemaJSONRequestBody) (*http.Response, error)

	// DeleteMysqlSchemaByUuuid request
	DeleteMysqlSchemaByUuuid(ctx context.Context, clusterUuid string, schemaUuid string) (*http.Response, error)

	// GetMysqlDatabaseTopology request
	GetMysqlDatabaseTopology(ctx context.Context, clusterUuid string) (*http.Response, error)

	// DeleteMysqlClsuterByUuid request
	DeleteMysqlClsuterByUuid(ctx context.Context, uuid string, params *DeleteMysqlClsuterByUuidParams) (*http.Response, error)

	// GetClusterByUuid request
	GetClusterByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// UpdateClusterByUuid request  with any body
	UpdateClusterByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateClusterByUuid(ctx context.Context, uuid string, body UpdateClusterByUuidJSONRequestBody) (*http.Response, error)

	// ListMysqlConfig request
	ListMysqlConfig(ctx context.Context) (*http.Response, error)

	// CreateMysqlConfig request  with any body
	CreateMysqlConfigWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateMysqlConfig(ctx context.Context, body CreateMysqlConfigJSONRequestBody) (*http.Response, error)

	// DeleteMysqlConfigByUuid request
	DeleteMysqlConfigByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// UpdateMysqlConfigByUuid request  with any body
	UpdateMysqlConfigByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateMysqlConfigByUuid(ctx context.Context, uuid string, body UpdateMysqlConfigByUuidJSONRequestBody) (*http.Response, error)

	// CreateRecreatedInstance request
	CreateRecreatedInstance(ctx context.Context, uuid string) (*http.Response, error)

	// ListMySQLAuditLog request
	ListMySQLAuditLog(ctx context.Context, params *ListMySQLAuditLogParams) (*http.Response, error)

	// ListMySQLSwitchMasterLog request
	ListMySQLSwitchMasterLog(ctx context.Context, params *ListMySQLSwitchMasterLogParams) (*http.Response, error)

	// ListMysqlProxy request
	ListMysqlProxy(ctx context.Context) (*http.Response, error)

	// CreateMysqlProxy request  with any body
	CreateMysqlProxyWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateMysqlProxy(ctx context.Context, body CreateMysqlProxyJSONRequestBody) (*http.Response, error)

	// DeleteMysqlProxyByUuid request
	DeleteMysqlProxyByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// ListMysqlProxyBuCluster request
	ListMysqlProxyBuCluster(ctx context.Context, uuid string) (*http.Response, error)

	// UpdateMySQLProxyByUuid request  with any body
	UpdateMySQLProxyByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateMySQLProxyByUuid(ctx context.Context, uuid string, body UpdateMySQLProxyByUuidJSONRequestBody) (*http.Response, error)

	// ListMysqlProxyAccounts request
	ListMysqlProxyAccounts(ctx context.Context, uuid string) (*http.Response, error)

	// CreateMysqlProxyAccount request  with any body
	CreateMysqlProxyAccountWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	CreateMysqlProxyAccount(ctx context.Context, uuid string, body CreateMysqlProxyAccountJSONRequestBody) (*http.Response, error)

	// UpdateMysqlProxyAccount request  with any body
	UpdateMysqlProxyAccountWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateMysqlProxyAccount(ctx context.Context, uuid string, body UpdateMysqlProxyAccountJSONRequestBody) (*http.Response, error)

	// DeleteMyqlProxyAccount request
	DeleteMyqlProxyAccount(ctx context.Context, uuid string, accountName string) (*http.Response, error)

	// GetMysqlSlowQueryLog request
	GetMysqlSlowQueryLog(ctx context.Context) (*http.Response, error)

	// ListNamespaces request
	ListNamespaces(ctx context.Context) (*http.Response, error)

	// ListOracleCluster request
	ListOracleCluster(ctx context.Context, params *ListOracleClusterParams) (*http.Response, error)

	// CreateOracleCluster request  with any body
	CreateOracleClusterWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateOracleCluster(ctx context.Context, body CreateOracleClusterJSONRequestBody) (*http.Response, error)

	// UpdateOracleAccount request  with any body
	UpdateOracleAccountWithBody(ctx context.Context, clusterUuid string, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateOracleAccount(ctx context.Context, clusterUuid string, uuid string, body UpdateOracleAccountJSONRequestBody) (*http.Response, error)

	// ListOracleSchemas request
	ListOracleSchemas(ctx context.Context, clusterUuid string) (*http.Response, error)

	// DeleteOracleClusterByUuid request
	DeleteOracleClusterByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// GetOracleClusterByUui request
	GetOracleClusterByUui(ctx context.Context, uuid string) (*http.Response, error)

	// UpdateOracleClusterByUuid request  with any body
	UpdateOracleClusterByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateOracleClusterByUuid(ctx context.Context, uuid string, body UpdateOracleClusterByUuidJSONRequestBody) (*http.Response, error)

	// ListOracleAccount request
	ListOracleAccount(ctx context.Context, clusterUuid string) (*http.Response, error)

	// GetClusterOverview request
	GetClusterOverview(ctx context.Context) (*http.Response, error)

	// CreateDepartmentReport request  with any body
	CreateDepartmentReportWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateDepartmentReport(ctx context.Context, body CreateDepartmentReportJSONRequestBody) (*http.Response, error)

	// CreateSystemReport request  with any body
	CreateSystemReportWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateSystemReport(ctx context.Context, body CreateSystemReportJSONRequestBody) (*http.Response, error)

	// ListStorageClasses request
	ListStorageClasses(ctx context.Context) (*http.Response, error)

	// PutApiV1TagClusterUuid request  with any body
	PutApiV1TagClusterUuidWithBody(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*http.Response, error)

	PutApiV1TagClusterUuid(ctx context.Context, clusterUuid string, body PutApiV1TagClusterUuidJSONRequestBody) (*http.Response, error)

	// ListUsers request  with any body
	ListUsersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	ListUsers(ctx context.Context, body ListUsersJSONRequestBody) (*http.Response, error)

	// CreateUser request  with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody) (*http.Response, error)

	// DeleteUserByUuid request
	DeleteUserByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// UpdateUserByUuid request  with any body
	UpdateUserByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateUserByUuid(ctx context.Context, uuid string, body UpdateUserByUuidJSONRequestBody) (*http.Response, error)

	// ListPersistentVolumes request
	ListPersistentVolumes(ctx context.Context, params *ListPersistentVolumesParams) (*http.Response, error)

	// ListClusterDatabaseVolumes request
	ListClusterDatabaseVolumes(ctx context.Context, clusterUuid string) (*http.Response, error)

	// ListImages request
	ListImages(ctx context.Context) (*http.Response, error)

	// GetImageByUuid request
	GetImageByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// ListOfferings request
	ListOfferings(ctx context.Context) (*http.Response, error)

	// GetOfferingByUuid request
	GetOfferingByUuid(ctx context.Context, uuid string) (*http.Response, error)

	// ListWorkNodes request
	ListWorkNodes(ctx context.Context, params *ListWorkNodesParams) (*http.Response, error)

	// DrainNodeByNodeName request
	DrainNodeByNodeName(ctx context.Context, nodeName string) (*http.Response, error)

	// GetNodeResource request
	GetNodeResource(ctx context.Context, nodeName string) (*http.Response, error)

	// UncordonNodeByNodeName request
	UncordonNodeByNodeName(ctx context.Context, nodeName string) (*http.Response, error)

	// ListBackups request
	ListBackups(ctx context.Context, clusterType ClusterType) (*http.Response, error)

	// DeleteBackupSetByUuid request
	DeleteBackupSetByUuid(ctx context.Context, clusterType ClusterType, uuid string) (*http.Response, error)

	// ListClusterBackupSets request
	ListClusterBackupSets(ctx context.Context, clusterType ClusterType, params *ListClusterBackupSetsParams) (*http.Response, error)

	// GetBackupsByClusterUuid request
	GetBackupsByClusterUuid(ctx context.Context, clusterType ClusterType, uuid string) (*http.Response, error)

	// CreateFullBackupJob request  with any body
	CreateFullBackupJobWithBody(ctx context.Context, clusterType ClusterType, contentType string, body io.Reader) (*http.Response, error)

	CreateFullBackupJob(ctx context.Context, clusterType ClusterType, body CreateFullBackupJobJSONRequestBody) (*http.Response, error)

	// CreateRestores request  with any body
	CreateRestoresWithBody(ctx context.Context, clusterType ClusterType, contentType string, body io.Reader) (*http.Response, error)

	CreateRestores(ctx context.Context, clusterType ClusterType, body CreateRestoresJSONRequestBody) (*http.Response, error)

	// ListBackupSets request
	ListBackupSets(ctx context.Context, clusterType ClusterType, backupUuid string, params *ListBackupSetsParams) (*http.Response, error)

	// GetBackupsByUuid request
	GetBackupsByUuid(ctx context.Context, clusterType ClusterType, uuid string) (*http.Response, error)

	// UpdateBackupByUuid request  with any body
	UpdateBackupByUuidWithBody(ctx context.Context, clusterType ClusterType, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateBackupByUuid(ctx context.Context, clusterType ClusterType, uuid string, body UpdateBackupByUuidJSONRequestBody) (*http.Response, error)

	// ListDatabaseAccount request
	ListDatabaseAccount(ctx context.Context, clusterType ClusterType, clusterUuid string) (*http.Response, error)

	// CreateDatabaseAccount request  with any body
	CreateDatabaseAccountWithBody(ctx context.Context, clusterType ClusterType, clusterUuid string, contentType string, body io.Reader) (*http.Response, error)

	CreateDatabaseAccount(ctx context.Context, clusterType ClusterType, clusterUuid string, body CreateDatabaseAccountJSONRequestBody) (*http.Response, error)

	// DeleteDatabaseAccountByUuid request
	DeleteDatabaseAccountByUuid(ctx context.Context, clusterType ClusterType, clusterUuid string, uuid string) (*http.Response, error)

	// UpdateDatabaseAccount request  with any body
	UpdateDatabaseAccountWithBody(ctx context.Context, clusterType ClusterType, clusterUuid string, uuid string, contentType string, body io.Reader) (*http.Response, error)

	UpdateDatabaseAccount(ctx context.Context, clusterType ClusterType, clusterUuid string, uuid string, body UpdateDatabaseAccountJSONRequestBody) (*http.Response, error)

	// ListClusterDatabaseInstances request
	ListClusterDatabaseInstances(ctx context.Context, clusterType ClusterType, clusterUuid string) (*http.Response, error)

	// GetDatabaseInstacneByUuid request
	GetDatabaseInstacneByUuid(ctx context.Context, clusterType ClusterType, uuid string) (*http.Response, error)

	// ForbidInstance request
	ForbidInstance(ctx context.Context, engine string, uuid string) (*http.Response, error)
}

func (c *Client) ListStorageInterface(ctx context.Context) (*http.Response, error) {
	req, err := NewListStorageInterfaceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageInterfaceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateStorageInterfaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageInterface(ctx context.Context, body CreateStorageInterfaceJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateStorageInterfaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackupByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewDeleteBackupByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageInterfaceByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetStorageInterfaceByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageInterfaceByUuid(ctx context.Context, uuid string, body GetStorageInterfaceByUuidJSONRequestBody) (*http.Response, error) {
	req, err := NewGetStorageInterfaceByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageInterfaceStatusByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewGetStorageInterfaceStatusByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusterWhitelist(ctx context.Context, clusterUuid string, params *ListClusterWhitelistParams) (*http.Response, error) {
	req, err := NewListClusterWhitelistRequest(c.Server, clusterUuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWhitelistWithBody(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateClusterWhitelistRequestWithBody(c.Server, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWhitelist(ctx context.Context, clusterUuid string, body CreateClusterWhitelistJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateClusterWhitelistRequest(c.Server, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClusterWhitelist(ctx context.Context, clusterUuid string, uuid string) (*http.Response, error) {
	req, err := NewDeleteClusterWhitelistRequest(c.Server, clusterUuid, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWhitelistWithBody(ctx context.Context, clusterUuid string, uuid string, params *UpdateClusterWhitelistParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateClusterWhitelistRequestWithBody(c.Server, clusterUuid, uuid, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWhitelist(ctx context.Context, clusterUuid string, uuid string, params *UpdateClusterWhitelistParams, body UpdateClusterWhitelistJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateClusterWhitelistRequest(c.Server, clusterUuid, uuid, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContainerShell(ctx context.Context, params *CreateContainerShellParams) (*http.Response, error) {
	req, err := NewCreateContainerShellRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatabaseTarget(ctx context.Context) (*http.Response, error) {
	req, err := NewListDatabaseTargetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseTargetWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateDatabaseTargetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseTarget(ctx context.Context, body CreateDatabaseTargetJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateDatabaseTargetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateMonitorUserPrivilegeWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewValidateMonitorUserPrivilegeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateMonitorUserPrivilege(ctx context.Context, body ValidateMonitorUserPrivilegeJSONRequestBody) (*http.Response, error) {
	req, err := NewValidateMonitorUserPrivilegeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatabaseTargetByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewDeleteDatabaseTargetByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseTargetByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewGetDatabaseTargetByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabaseTargetByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateDatabaseTargetByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabaseTargetByUuid(ctx context.Context, uuid string, body UpdateDatabaseTargetByUuidJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateDatabaseTargetByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatetime(ctx context.Context) (*http.Response, error) {
	req, err := NewGetDatetimeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatetimeWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateDatetimeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatetime(ctx context.Context, body UpdateDatetimeJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateDatetimeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEventWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEvent(ctx context.Context, body CreateEventJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventPage(ctx context.Context, params *ListEventPageParams) (*http.Response, error) {
	req, err := NewListEventPageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListNetwork(ctx context.Context) (*http.Response, error) {
	req, err := NewListNetworkRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetworkWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateNetworkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetwork(ctx context.Context, body CreateNetworkJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateNetworkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleleNetworkAddressByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewDeleleNetworkAddressByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNewtorkByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewDeleteNewtorkByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetworkAddressWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateNetworkAddressRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetworkAddress(ctx context.Context, uuid string, body CreateNetworkAddressJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateNetworkAddressRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVIPValiation(ctx context.Context, ip string) (*http.Response, error) {
	req, err := NewCreateVIPValiationRequest(c.Server, ip)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetK8sResourceOverview(ctx context.Context) (*http.Response, error) {
	req, err := NewGetK8sResourceOverviewRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicense(ctx context.Context, params *GetLicenseParams) (*http.Response, error) {
	req, err := NewGetLicenseRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLicenseWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateLicenseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLicense(ctx context.Context, body UpdateLicenseJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateLicenseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) LoginUserWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewLoginUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) LoginUser(ctx context.Context, body LoginUserJSONRequestBody) (*http.Response, error) {
	req, err := NewLoginUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMySQLAggregatedSlowQueryLog(ctx context.Context, params *ListMySQLAggregatedSlowQueryLogParams) (*http.Response, error) {
	req, err := NewListMySQLAggregatedSlowQueryLogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMySQLErrorLog(ctx context.Context, params *ListMySQLErrorLogParams) (*http.Response, error) {
	req, err := NewListMySQLErrorLogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMySQLSlowQueryLog(ctx context.Context, params *ListMySQLSlowQueryLogParams) (*http.Response, error) {
	req, err := NewListMySQLSlowQueryLogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMssqlClsuters(ctx context.Context, params *ListMssqlClsutersParams) (*http.Response, error) {
	req, err := NewListMssqlClsutersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMssqlClusterWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateMssqlClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMssqlCluster(ctx context.Context, body CreateMssqlClusterJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateMssqlClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMssqlSchema(ctx context.Context, clusterUuid string) (*http.Response, error) {
	req, err := NewListMssqlSchemaRequest(c.Server, clusterUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMssqlSchemaWithBody(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateMssqlSchemaRequestWithBody(c.Server, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMssqlSchema(ctx context.Context, clusterUuid string, body CreateMssqlSchemaJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateMssqlSchemaRequest(c.Server, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMssqlSchemaByUuid(ctx context.Context, clusterUuid string, uuid string) (*http.Response, error) {
	req, err := NewDeleteMssqlSchemaByUuidRequest(c.Server, clusterUuid, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMssqlClusterByUuid(ctx context.Context, uuid string, params *DeleteMssqlClusterByUuidParams) (*http.Response, error) {
	req, err := NewDeleteMssqlClusterByUuidRequest(c.Server, uuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMssqlCluster(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewGetMssqlClusterRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMssqlClusterByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateMssqlClusterByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMssqlClusterByUuid(ctx context.Context, uuid string, body UpdateMssqlClusterByUuidJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateMssqlClusterByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMysqlCluster(ctx context.Context, params *ListMysqlClusterParams) (*http.Response, error) {
	req, err := NewListMysqlClusterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMysqlClusterWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateMysqlClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMysqlCluster(ctx context.Context, body CreateMysqlClusterJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateMysqlClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMysqlClusterConfig(ctx context.Context, clusterUuid string) (*http.Response, error) {
	req, err := NewListMysqlClusterConfigRequest(c.Server, clusterUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMysqlClusterConfigWithBody(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateMysqlClusterConfigRequestWithBody(c.Server, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMysqlClusterConfig(ctx context.Context, clusterUuid string, body UpdateMysqlClusterConfigJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateMysqlClusterConfigRequest(c.Server, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMysqlDatabaseSchemas(ctx context.Context, clusterUuid string) (*http.Response, error) {
	req, err := NewListMysqlDatabaseSchemasRequest(c.Server, clusterUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMysqlSchemaWithBody(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateMysqlSchemaRequestWithBody(c.Server, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMysqlSchema(ctx context.Context, clusterUuid string, body CreateMysqlSchemaJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateMysqlSchemaRequest(c.Server, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMysqlSchemaByUuuid(ctx context.Context, clusterUuid string, schemaUuid string) (*http.Response, error) {
	req, err := NewDeleteMysqlSchemaByUuuidRequest(c.Server, clusterUuid, schemaUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMysqlDatabaseTopology(ctx context.Context, clusterUuid string) (*http.Response, error) {
	req, err := NewGetMysqlDatabaseTopologyRequest(c.Server, clusterUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMysqlClsuterByUuid(ctx context.Context, uuid string, params *DeleteMysqlClsuterByUuidParams) (*http.Response, error) {
	req, err := NewDeleteMysqlClsuterByUuidRequest(c.Server, uuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewGetClusterByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateClusterByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterByUuid(ctx context.Context, uuid string, body UpdateClusterByUuidJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateClusterByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMysqlConfig(ctx context.Context) (*http.Response, error) {
	req, err := NewListMysqlConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMysqlConfigWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateMysqlConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMysqlConfig(ctx context.Context, body CreateMysqlConfigJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateMysqlConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMysqlConfigByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewDeleteMysqlConfigByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMysqlConfigByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateMysqlConfigByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMysqlConfigByUuid(ctx context.Context, uuid string, body UpdateMysqlConfigByUuidJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateMysqlConfigByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRecreatedInstance(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewCreateRecreatedInstanceRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMySQLAuditLog(ctx context.Context, params *ListMySQLAuditLogParams) (*http.Response, error) {
	req, err := NewListMySQLAuditLogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMySQLSwitchMasterLog(ctx context.Context, params *ListMySQLSwitchMasterLogParams) (*http.Response, error) {
	req, err := NewListMySQLSwitchMasterLogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMysqlProxy(ctx context.Context) (*http.Response, error) {
	req, err := NewListMysqlProxyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMysqlProxyWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateMysqlProxyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMysqlProxy(ctx context.Context, body CreateMysqlProxyJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateMysqlProxyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMysqlProxyByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewDeleteMysqlProxyByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMysqlProxyBuCluster(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewListMysqlProxyBuClusterRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMySQLProxyByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateMySQLProxyByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMySQLProxyByUuid(ctx context.Context, uuid string, body UpdateMySQLProxyByUuidJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateMySQLProxyByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMysqlProxyAccounts(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewListMysqlProxyAccountsRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMysqlProxyAccountWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateMysqlProxyAccountRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMysqlProxyAccount(ctx context.Context, uuid string, body CreateMysqlProxyAccountJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateMysqlProxyAccountRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMysqlProxyAccountWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateMysqlProxyAccountRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMysqlProxyAccount(ctx context.Context, uuid string, body UpdateMysqlProxyAccountJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateMysqlProxyAccountRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMyqlProxyAccount(ctx context.Context, uuid string, accountName string) (*http.Response, error) {
	req, err := NewDeleteMyqlProxyAccountRequest(c.Server, uuid, accountName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMysqlSlowQueryLog(ctx context.Context) (*http.Response, error) {
	req, err := NewGetMysqlSlowQueryLogRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListNamespaces(ctx context.Context) (*http.Response, error) {
	req, err := NewListNamespacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListOracleCluster(ctx context.Context, params *ListOracleClusterParams) (*http.Response, error) {
	req, err := NewListOracleClusterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOracleClusterWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateOracleClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOracleCluster(ctx context.Context, body CreateOracleClusterJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateOracleClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOracleAccountWithBody(ctx context.Context, clusterUuid string, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateOracleAccountRequestWithBody(c.Server, clusterUuid, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOracleAccount(ctx context.Context, clusterUuid string, uuid string, body UpdateOracleAccountJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateOracleAccountRequest(c.Server, clusterUuid, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListOracleSchemas(ctx context.Context, clusterUuid string) (*http.Response, error) {
	req, err := NewListOracleSchemasRequest(c.Server, clusterUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOracleClusterByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewDeleteOracleClusterByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetOracleClusterByUui(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewGetOracleClusterByUuiRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOracleClusterByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateOracleClusterByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOracleClusterByUuid(ctx context.Context, uuid string, body UpdateOracleClusterByUuidJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateOracleClusterByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListOracleAccount(ctx context.Context, clusterUuid string) (*http.Response, error) {
	req, err := NewListOracleAccountRequest(c.Server, clusterUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterOverview(ctx context.Context) (*http.Response, error) {
	req, err := NewGetClusterOverviewRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDepartmentReportWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateDepartmentReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDepartmentReport(ctx context.Context, body CreateDepartmentReportJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateDepartmentReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSystemReportWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateSystemReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSystemReport(ctx context.Context, body CreateSystemReportJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateSystemReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListStorageClasses(ctx context.Context) (*http.Response, error) {
	req, err := NewListStorageClassesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutApiV1TagClusterUuidWithBody(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutApiV1TagClusterUuidRequestWithBody(c.Server, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutApiV1TagClusterUuid(ctx context.Context, clusterUuid string, body PutApiV1TagClusterUuidJSONRequestBody) (*http.Response, error) {
	req, err := NewPutApiV1TagClusterUuidRequest(c.Server, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewListUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, body ListUsersJSONRequestBody) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewDeleteUserByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserByUuidWithBody(ctx context.Context, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateUserByUuidRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserByUuid(ctx context.Context, uuid string, body UpdateUserByUuidJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateUserByUuidRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListPersistentVolumes(ctx context.Context, params *ListPersistentVolumesParams) (*http.Response, error) {
	req, err := NewListPersistentVolumesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusterDatabaseVolumes(ctx context.Context, clusterUuid string) (*http.Response, error) {
	req, err := NewListClusterDatabaseVolumesRequest(c.Server, clusterUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListImages(ctx context.Context) (*http.Response, error) {
	req, err := NewListImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetImageByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewGetImageByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListOfferings(ctx context.Context) (*http.Response, error) {
	req, err := NewListOfferingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetOfferingByUuid(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewGetOfferingByUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkNodes(ctx context.Context, params *ListWorkNodesParams) (*http.Response, error) {
	req, err := NewListWorkNodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DrainNodeByNodeName(ctx context.Context, nodeName string) (*http.Response, error) {
	req, err := NewDrainNodeByNodeNameRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetNodeResource(ctx context.Context, nodeName string) (*http.Response, error) {
	req, err := NewGetNodeResourceRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UncordonNodeByNodeName(ctx context.Context, nodeName string) (*http.Response, error) {
	req, err := NewUncordonNodeByNodeNameRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListBackups(ctx context.Context, clusterType ClusterType) (*http.Response, error) {
	req, err := NewListBackupsRequest(c.Server, clusterType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackupSetByUuid(ctx context.Context, clusterType ClusterType, uuid string) (*http.Response, error) {
	req, err := NewDeleteBackupSetByUuidRequest(c.Server, clusterType, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusterBackupSets(ctx context.Context, clusterType ClusterType, params *ListClusterBackupSetsParams) (*http.Response, error) {
	req, err := NewListClusterBackupSetsRequest(c.Server, clusterType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupsByClusterUuid(ctx context.Context, clusterType ClusterType, uuid string) (*http.Response, error) {
	req, err := NewGetBackupsByClusterUuidRequest(c.Server, clusterType, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFullBackupJobWithBody(ctx context.Context, clusterType ClusterType, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateFullBackupJobRequestWithBody(c.Server, clusterType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFullBackupJob(ctx context.Context, clusterType ClusterType, body CreateFullBackupJobJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateFullBackupJobRequest(c.Server, clusterType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRestoresWithBody(ctx context.Context, clusterType ClusterType, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateRestoresRequestWithBody(c.Server, clusterType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRestores(ctx context.Context, clusterType ClusterType, body CreateRestoresJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateRestoresRequest(c.Server, clusterType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListBackupSets(ctx context.Context, clusterType ClusterType, backupUuid string, params *ListBackupSetsParams) (*http.Response, error) {
	req, err := NewListBackupSetsRequest(c.Server, clusterType, backupUuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupsByUuid(ctx context.Context, clusterType ClusterType, uuid string) (*http.Response, error) {
	req, err := NewGetBackupsByUuidRequest(c.Server, clusterType, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBackupByUuidWithBody(ctx context.Context, clusterType ClusterType, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateBackupByUuidRequestWithBody(c.Server, clusterType, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBackupByUuid(ctx context.Context, clusterType ClusterType, uuid string, body UpdateBackupByUuidJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateBackupByUuidRequest(c.Server, clusterType, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatabaseAccount(ctx context.Context, clusterType ClusterType, clusterUuid string) (*http.Response, error) {
	req, err := NewListDatabaseAccountRequest(c.Server, clusterType, clusterUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseAccountWithBody(ctx context.Context, clusterType ClusterType, clusterUuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateDatabaseAccountRequestWithBody(c.Server, clusterType, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseAccount(ctx context.Context, clusterType ClusterType, clusterUuid string, body CreateDatabaseAccountJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateDatabaseAccountRequest(c.Server, clusterType, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatabaseAccountByUuid(ctx context.Context, clusterType ClusterType, clusterUuid string, uuid string) (*http.Response, error) {
	req, err := NewDeleteDatabaseAccountByUuidRequest(c.Server, clusterType, clusterUuid, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabaseAccountWithBody(ctx context.Context, clusterType ClusterType, clusterUuid string, uuid string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateDatabaseAccountRequestWithBody(c.Server, clusterType, clusterUuid, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabaseAccount(ctx context.Context, clusterType ClusterType, clusterUuid string, uuid string, body UpdateDatabaseAccountJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateDatabaseAccountRequest(c.Server, clusterType, clusterUuid, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusterDatabaseInstances(ctx context.Context, clusterType ClusterType, clusterUuid string) (*http.Response, error) {
	req, err := NewListClusterDatabaseInstancesRequest(c.Server, clusterType, clusterUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseInstacneByUuid(ctx context.Context, clusterType ClusterType, uuid string) (*http.Response, error) {
	req, err := NewGetDatabaseInstacneByUuidRequest(c.Server, clusterType, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ForbidInstance(ctx context.Context, engine string, uuid string) (*http.Response, error) {
	req, err := NewForbidInstanceRequest(c.Server, engine, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewListStorageInterfaceRequest generates requests for ListStorageInterface
func NewListStorageInterfaceRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/backups/storage_interfaces"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageInterfaceRequest calls the generic CreateStorageInterface builder with application/json body
func NewCreateStorageInterfaceRequest(server string, body CreateStorageInterfaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStorageInterfaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateStorageInterfaceRequestWithBody generates requests for CreateStorageInterface with any type of body
func NewCreateStorageInterfaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/backups/storage_interfaces"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteBackupByUuidRequest generates requests for DeleteBackupByUuid
func NewDeleteBackupByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/backups/storage_interfaces/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageInterfaceByUuidRequest calls the generic GetStorageInterfaceByUuid builder with application/json body
func NewGetStorageInterfaceByUuidRequest(server string, uuid string, body GetStorageInterfaceByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetStorageInterfaceByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewGetStorageInterfaceByUuidRequestWithBody generates requests for GetStorageInterfaceByUuid with any type of body
func NewGetStorageInterfaceByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/backups/storage_interfaces/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetStorageInterfaceStatusByUuidRequest generates requests for GetStorageInterfaceStatusByUuid
func NewGetStorageInterfaceStatusByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/backups/storage_interfaces/%s/status", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClusterWhitelistRequest generates requests for ListClusterWhitelist
func NewListClusterWhitelistRequest(server string, clusterUuid string, params *ListClusterWhitelistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/clusters/%s/whitelist", pathParam0))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.PageNum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageNum", *params.PageNum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageSize", *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterWhitelistRequest calls the generic CreateClusterWhitelist builder with application/json body
func NewCreateClusterWhitelistRequest(server string, clusterUuid string, body CreateClusterWhitelistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterWhitelistRequestWithBody(server, clusterUuid, "application/json", bodyReader)
}

// NewCreateClusterWhitelistRequestWithBody generates requests for CreateClusterWhitelist with any type of body
func NewCreateClusterWhitelistRequestWithBody(server string, clusterUuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/clusters/%s/whitelist", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteClusterWhitelistRequest generates requests for DeleteClusterWhitelist
func NewDeleteClusterWhitelistRequest(server string, clusterUuid string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/clusters/%s/whitelist/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterWhitelistRequest calls the generic UpdateClusterWhitelist builder with application/json body
func NewUpdateClusterWhitelistRequest(server string, clusterUuid string, uuid string, params *UpdateClusterWhitelistParams, body UpdateClusterWhitelistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterWhitelistRequestWithBody(server, clusterUuid, uuid, params, "application/json", bodyReader)
}

// NewUpdateClusterWhitelistRequestWithBody generates requests for UpdateClusterWhitelist with any type of body
func NewUpdateClusterWhitelistRequestWithBody(server string, clusterUuid string, uuid string, params *UpdateClusterWhitelistParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/clusters/%s/whitelist/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Append != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "append", *params.Append); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewCreateContainerShellRequest generates requests for CreateContainerShell
func NewCreateContainerShellRequest(server string, params *CreateContainerShellParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/container_shell/ws"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Pod != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pod", *params.Pod); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Namespace != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "namespace", *params.Namespace); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Container != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "container", *params.Container); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Command != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "command", *params.Command); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDatabaseTargetRequest generates requests for ListDatabaseTarget
func NewListDatabaseTargetRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/database_targets"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabaseTargetRequest calls the generic CreateDatabaseTarget builder with application/json body
func NewCreateDatabaseTargetRequest(server string, body CreateDatabaseTargetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseTargetRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseTargetRequestWithBody generates requests for CreateDatabaseTarget with any type of body
func NewCreateDatabaseTargetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/database_targets"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewValidateMonitorUserPrivilegeRequest calls the generic ValidateMonitorUserPrivilege builder with application/json body
func NewValidateMonitorUserPrivilegeRequest(server string, body ValidateMonitorUserPrivilegeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateMonitorUserPrivilegeRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateMonitorUserPrivilegeRequestWithBody generates requests for ValidateMonitorUserPrivilege with any type of body
func NewValidateMonitorUserPrivilegeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/database_targets/monitor_user_validation"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteDatabaseTargetByUuidRequest generates requests for DeleteDatabaseTargetByUuid
func NewDeleteDatabaseTargetByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/database_targets/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseTargetByUuidRequest generates requests for GetDatabaseTargetByUuid
func NewGetDatabaseTargetByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/database_targets/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatabaseTargetByUuidRequest calls the generic UpdateDatabaseTargetByUuid builder with application/json body
func NewUpdateDatabaseTargetByUuidRequest(server string, uuid string, body UpdateDatabaseTargetByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatabaseTargetByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateDatabaseTargetByUuidRequestWithBody generates requests for UpdateDatabaseTargetByUuid with any type of body
func NewUpdateDatabaseTargetByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/database_targets/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetDatetimeRequest generates requests for GetDatetime
func NewGetDatetimeRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/datetime"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatetimeRequest calls the generic UpdateDatetime builder with application/json body
func NewUpdateDatetimeRequest(server string, body UpdateDatetimeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatetimeRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateDatetimeRequestWithBody generates requests for UpdateDatetime with any type of body
func NewUpdateDatetimeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/datetime"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewCreateEventRequest calls the generic CreateEvent builder with application/json body
func NewCreateEventRequest(server string, body CreateEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEventRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEventRequestWithBody generates requests for CreateEvent with any type of body
func NewCreateEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/event"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListEventPageRequest generates requests for ListEventPage
func NewListEventPageRequest(server string, params *ListEventPageParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/event/page"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "user_id", params.UserId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParam("form", true, "cluster_id", params.ClusterId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParam("form", true, "startTime", params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParam("form", true, "endTime", params.EndTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Description != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "description", *params.Description); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "status", *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UserName != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "user_name", *params.UserName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortType != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortType", *params.SortType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortField != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortField", *params.SortField); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageNum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageNum", *params.PageNum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageSize", *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNetworkRequest generates requests for ListNetwork
func NewListNetworkRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/ip_management/networks"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNetworkRequest calls the generic CreateNetwork builder with application/json body
func NewCreateNetworkRequest(server string, body CreateNetworkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNetworkRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNetworkRequestWithBody generates requests for CreateNetwork with any type of body
func NewCreateNetworkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/ip_management/networks"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleleNetworkAddressByUuidRequest generates requests for DeleleNetworkAddressByUuid
func NewDeleleNetworkAddressByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/ip_management/networks/addresses/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNewtorkByUuidRequest generates requests for DeleteNewtorkByUuid
func NewDeleteNewtorkByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/ip_management/networks/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNetworkAddressRequest calls the generic CreateNetworkAddress builder with application/json body
func NewCreateNetworkAddressRequest(server string, uuid string, body CreateNetworkAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNetworkAddressRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewCreateNetworkAddressRequestWithBody generates requests for CreateNetworkAddress with any type of body
func NewCreateNetworkAddressRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/ip_management/networks/%s/addresses", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewCreateVIPValiationRequest generates requests for CreateVIPValiation
func NewCreateVIPValiationRequest(server string, ip string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "ip", ip)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/ip_management/%s/validation", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetK8sResourceOverviewRequest generates requests for GetK8sResourceOverview
func NewGetK8sResourceOverviewRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/k8s_overview"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLicenseRequest generates requests for GetLicense
func NewGetLicenseRequest(server string, params *GetLicenseParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/license"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Check != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "check", *params.Check); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLicenseRequest calls the generic UpdateLicense builder with application/json body
func NewUpdateLicenseRequest(server string, body UpdateLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLicenseRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateLicenseRequestWithBody generates requests for UpdateLicense with any type of body
func NewUpdateLicenseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/license"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewLoginUserRequest calls the generic LoginUser builder with application/json body
func NewLoginUserRequest(server string, body LoginUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginUserRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginUserRequestWithBody generates requests for LoginUser with any type of body
func NewLoginUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/login"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListMySQLAggregatedSlowQueryLogRequest generates requests for ListMySQLAggregatedSlowQueryLog
func NewListMySQLAggregatedSlowQueryLogRequest(server string, params *ListMySQLAggregatedSlowQueryLogParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/logs/aggregated_slow_query"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "clusterUuid", params.ClusterUuid); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Databases != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "databases", *params.Databases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "startTime", *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "endTime", *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageNum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageNum", *params.PageNum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageSize", *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMySQLErrorLogRequest generates requests for ListMySQLErrorLog
func NewListMySQLErrorLogRequest(server string, params *ListMySQLErrorLogParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/logs/error"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "clusterUuid", params.ClusterUuid); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "startTime", *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "endTime", *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageNum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageNum", *params.PageNum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageSize", *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMySQLSlowQueryLogRequest generates requests for ListMySQLSlowQueryLog
func NewListMySQLSlowQueryLogRequest(server string, params *ListMySQLSlowQueryLogParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/logs/slow_query"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "clusterUuid", params.ClusterUuid); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Databases != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "databases", *params.Databases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "startTime", *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "endTime", *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageNum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageNum", *params.PageNum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageSize", *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMssqlClsutersRequest generates requests for ListMssqlClsuters
func NewListMssqlClsutersRequest(server string, params *ListMssqlClsutersParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mssql/clusters"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sort_by", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "tag", *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMssqlClusterRequest calls the generic CreateMssqlCluster builder with application/json body
func NewCreateMssqlClusterRequest(server string, body CreateMssqlClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMssqlClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMssqlClusterRequestWithBody generates requests for CreateMssqlCluster with any type of body
func NewCreateMssqlClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mssql/clusters"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListMssqlSchemaRequest generates requests for ListMssqlSchema
func NewListMssqlSchemaRequest(server string, clusterUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mssql/clusters/%s/database_schemas", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMssqlSchemaRequest calls the generic CreateMssqlSchema builder with application/json body
func NewCreateMssqlSchemaRequest(server string, clusterUuid string, body CreateMssqlSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMssqlSchemaRequestWithBody(server, clusterUuid, "application/json", bodyReader)
}

// NewCreateMssqlSchemaRequestWithBody generates requests for CreateMssqlSchema with any type of body
func NewCreateMssqlSchemaRequestWithBody(server string, clusterUuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mssql/clusters/%s/database_schemas", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteMssqlSchemaByUuidRequest generates requests for DeleteMssqlSchemaByUuid
func NewDeleteMssqlSchemaByUuidRequest(server string, clusterUuid string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mssql/clusters/%s/database_schemas/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMssqlClusterByUuidRequest generates requests for DeleteMssqlClusterByUuid
func NewDeleteMssqlClusterByUuidRequest(server string, uuid string, params *DeleteMssqlClusterByUuidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mssql/clusters/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.DeleteBackup != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "deleteBackup", *params.DeleteBackup); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMssqlClusterRequest generates requests for GetMssqlCluster
func NewGetMssqlClusterRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mssql/clusters/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMssqlClusterByUuidRequest calls the generic UpdateMssqlClusterByUuid builder with application/json body
func NewUpdateMssqlClusterByUuidRequest(server string, uuid string, body UpdateMssqlClusterByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMssqlClusterByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateMssqlClusterByUuidRequestWithBody generates requests for UpdateMssqlClusterByUuid with any type of body
func NewUpdateMssqlClusterByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mssql/clusters/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListMysqlClusterRequest generates requests for ListMysqlCluster
func NewListMysqlClusterRequest(server string, params *ListMysqlClusterParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "filter", *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sort_by", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "tag", *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMysqlClusterRequest calls the generic CreateMysqlCluster builder with application/json body
func NewCreateMysqlClusterRequest(server string, body CreateMysqlClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMysqlClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMysqlClusterRequestWithBody generates requests for CreateMysqlCluster with any type of body
func NewCreateMysqlClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListMysqlClusterConfigRequest generates requests for ListMysqlClusterConfig
func NewListMysqlClusterConfigRequest(server string, clusterUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters/%s/config", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMysqlClusterConfigRequest calls the generic UpdateMysqlClusterConfig builder with application/json body
func NewUpdateMysqlClusterConfigRequest(server string, clusterUuid string, body UpdateMysqlClusterConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMysqlClusterConfigRequestWithBody(server, clusterUuid, "application/json", bodyReader)
}

// NewUpdateMysqlClusterConfigRequestWithBody generates requests for UpdateMysqlClusterConfig with any type of body
func NewUpdateMysqlClusterConfigRequestWithBody(server string, clusterUuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters/%s/config", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListMysqlDatabaseSchemasRequest generates requests for ListMysqlDatabaseSchemas
func NewListMysqlDatabaseSchemasRequest(server string, clusterUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters/%s/database_schemas", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMysqlSchemaRequest calls the generic CreateMysqlSchema builder with application/json body
func NewCreateMysqlSchemaRequest(server string, clusterUuid string, body CreateMysqlSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMysqlSchemaRequestWithBody(server, clusterUuid, "application/json", bodyReader)
}

// NewCreateMysqlSchemaRequestWithBody generates requests for CreateMysqlSchema with any type of body
func NewCreateMysqlSchemaRequestWithBody(server string, clusterUuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters/%s/database_schemas", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteMysqlSchemaByUuuidRequest generates requests for DeleteMysqlSchemaByUuuid
func NewDeleteMysqlSchemaByUuuidRequest(server string, clusterUuid string, schemaUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "schema_uuid", schemaUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters/%s/database_schemas/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMysqlDatabaseTopologyRequest generates requests for GetMysqlDatabaseTopology
func NewGetMysqlDatabaseTopologyRequest(server string, clusterUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters/%s/database_topology", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMysqlClsuterByUuidRequest generates requests for DeleteMysqlClsuterByUuid
func NewDeleteMysqlClsuterByUuidRequest(server string, uuid string, params *DeleteMysqlClsuterByUuidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.DeleteBackup != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "deleteBackup", *params.DeleteBackup); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterByUuidRequest generates requests for GetClusterByUuid
func NewGetClusterByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterByUuidRequest calls the generic UpdateClusterByUuid builder with application/json body
func NewUpdateClusterByUuidRequest(server string, uuid string, body UpdateClusterByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateClusterByUuidRequestWithBody generates requests for UpdateClusterByUuid with any type of body
func NewUpdateClusterByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/clusters/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListMysqlConfigRequest generates requests for ListMysqlConfig
func NewListMysqlConfigRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/config"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMysqlConfigRequest calls the generic CreateMysqlConfig builder with application/json body
func NewCreateMysqlConfigRequest(server string, body CreateMysqlConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMysqlConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMysqlConfigRequestWithBody generates requests for CreateMysqlConfig with any type of body
func NewCreateMysqlConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/config"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteMysqlConfigByUuidRequest generates requests for DeleteMysqlConfigByUuid
func NewDeleteMysqlConfigByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/config/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMysqlConfigByUuidRequest calls the generic UpdateMysqlConfigByUuid builder with application/json body
func NewUpdateMysqlConfigByUuidRequest(server string, uuid string, body UpdateMysqlConfigByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMysqlConfigByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateMysqlConfigByUuidRequestWithBody generates requests for UpdateMysqlConfigByUuid with any type of body
func NewUpdateMysqlConfigByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/config/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewCreateRecreatedInstanceRequest generates requests for CreateRecreatedInstance
func NewCreateRecreatedInstanceRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/database_instances/%s/recreated_instances", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMySQLAuditLogRequest generates requests for ListMySQLAuditLog
func NewListMySQLAuditLogRequest(server string, params *ListMySQLAuditLogParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/logs/audit"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "clusterUuid", params.ClusterUuid); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "startTime", *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "endTime", *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Db != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "db", *params.Db); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.User != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "user", *params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Class != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "class", *params.Class); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageNum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageNum", *params.PageNum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageSize", *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMySQLSwitchMasterLogRequest generates requests for ListMySQLSwitchMasterLog
func NewListMySQLSwitchMasterLogRequest(server string, params *ListMySQLSwitchMasterLogParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/logs/switch_master"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "clusterUuid", params.ClusterUuid); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "startTime", *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "endTime", *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageNum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageNum", *params.PageNum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageSize", *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMysqlProxyRequest generates requests for ListMysqlProxy
func NewListMysqlProxyRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/proxys"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMysqlProxyRequest calls the generic CreateMysqlProxy builder with application/json body
func NewCreateMysqlProxyRequest(server string, body CreateMysqlProxyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMysqlProxyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMysqlProxyRequestWithBody generates requests for CreateMysqlProxy with any type of body
func NewCreateMysqlProxyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/proxys"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteMysqlProxyByUuidRequest generates requests for DeleteMysqlProxyByUuid
func NewDeleteMysqlProxyByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/proxys/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMysqlProxyBuClusterRequest generates requests for ListMysqlProxyBuCluster
func NewListMysqlProxyBuClusterRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/proxys/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMySQLProxyByUuidRequest calls the generic UpdateMySQLProxyByUuid builder with application/json body
func NewUpdateMySQLProxyByUuidRequest(server string, uuid string, body UpdateMySQLProxyByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMySQLProxyByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateMySQLProxyByUuidRequestWithBody generates requests for UpdateMySQLProxyByUuid with any type of body
func NewUpdateMySQLProxyByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/proxys/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListMysqlProxyAccountsRequest generates requests for ListMysqlProxyAccounts
func NewListMysqlProxyAccountsRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/proxys/%s/accounts", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMysqlProxyAccountRequest calls the generic CreateMysqlProxyAccount builder with application/json body
func NewCreateMysqlProxyAccountRequest(server string, uuid string, body CreateMysqlProxyAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMysqlProxyAccountRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewCreateMysqlProxyAccountRequestWithBody generates requests for CreateMysqlProxyAccount with any type of body
func NewCreateMysqlProxyAccountRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/proxys/%s/accounts", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewUpdateMysqlProxyAccountRequest calls the generic UpdateMysqlProxyAccount builder with application/json body
func NewUpdateMysqlProxyAccountRequest(server string, uuid string, body UpdateMysqlProxyAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMysqlProxyAccountRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateMysqlProxyAccountRequestWithBody generates requests for UpdateMysqlProxyAccount with any type of body
func NewUpdateMysqlProxyAccountRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/proxys/%s/accounts", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteMyqlProxyAccountRequest generates requests for DeleteMyqlProxyAccount
func NewDeleteMyqlProxyAccountRequest(server string, uuid string, accountName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "account_name", accountName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/proxys/%s/accounts/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMysqlSlowQueryLogRequest generates requests for GetMysqlSlowQueryLog
func NewGetMysqlSlowQueryLogRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/mysql/slow_query_log"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNamespacesRequest generates requests for ListNamespaces
func NewListNamespacesRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/namespaces"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOracleClusterRequest generates requests for ListOracleCluster
func NewListOracleClusterRequest(server string, params *ListOracleClusterParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/oracle/clusters"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sort_by", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "tag", *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOracleClusterRequest calls the generic CreateOracleCluster builder with application/json body
func NewCreateOracleClusterRequest(server string, body CreateOracleClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOracleClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOracleClusterRequestWithBody generates requests for CreateOracleCluster with any type of body
func NewCreateOracleClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/oracle/clusters"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewUpdateOracleAccountRequest calls the generic UpdateOracleAccount builder with application/json body
func NewUpdateOracleAccountRequest(server string, clusterUuid string, uuid string, body UpdateOracleAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOracleAccountRequestWithBody(server, clusterUuid, uuid, "application/json", bodyReader)
}

// NewUpdateOracleAccountRequestWithBody generates requests for UpdateOracleAccount with any type of body
func NewUpdateOracleAccountRequestWithBody(server string, clusterUuid string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/oracle/clusters/%s/database_accounts/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListOracleSchemasRequest generates requests for ListOracleSchemas
func NewListOracleSchemasRequest(server string, clusterUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/oracle/clusters/%s/database_schemas", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteOracleClusterByUuidRequest generates requests for DeleteOracleClusterByUuid
func NewDeleteOracleClusterByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/oracle/clusters/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOracleClusterByUuiRequest generates requests for GetOracleClusterByUui
func NewGetOracleClusterByUuiRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/oracle/clusters/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOracleClusterByUuidRequest calls the generic UpdateOracleClusterByUuid builder with application/json body
func NewUpdateOracleClusterByUuidRequest(server string, uuid string, body UpdateOracleClusterByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOracleClusterByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateOracleClusterByUuidRequestWithBody generates requests for UpdateOracleClusterByUuid with any type of body
func NewUpdateOracleClusterByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/oracle/clusters/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListOracleAccountRequest generates requests for ListOracleAccount
func NewListOracleAccountRequest(server string, clusterUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/oracle/%s/database_accounts", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterOverviewRequest generates requests for GetClusterOverview
func NewGetClusterOverviewRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/overview"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDepartmentReportRequest calls the generic CreateDepartmentReport builder with application/json body
func NewCreateDepartmentReportRequest(server string, body CreateDepartmentReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDepartmentReportRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDepartmentReportRequestWithBody generates requests for CreateDepartmentReport with any type of body
func NewCreateDepartmentReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/reports/department"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewCreateSystemReportRequest calls the generic CreateSystemReport builder with application/json body
func NewCreateSystemReportRequest(server string, body CreateSystemReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSystemReportRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSystemReportRequestWithBody generates requests for CreateSystemReport with any type of body
func NewCreateSystemReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/reports/system"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListStorageClassesRequest generates requests for ListStorageClasses
func NewListStorageClassesRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/storage_classes"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutApiV1TagClusterUuidRequest calls the generic PutApiV1TagClusterUuid builder with application/json body
func NewPutApiV1TagClusterUuidRequest(server string, clusterUuid string, body PutApiV1TagClusterUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutApiV1TagClusterUuidRequestWithBody(server, clusterUuid, "application/json", bodyReader)
}

// NewPutApiV1TagClusterUuidRequestWithBody generates requests for PutApiV1TagClusterUuid with any type of body
func NewPutApiV1TagClusterUuidRequestWithBody(server string, clusterUuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/tag/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListUsersRequest calls the generic ListUsers builder with application/json body
func NewListUsersRequest(server string, body ListUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewListUsersRequestWithBody generates requests for ListUsers with any type of body
func NewListUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/users"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/users"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteUserByUuidRequest generates requests for DeleteUserByUuid
func NewDeleteUserByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/users/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserByUuidRequest calls the generic UpdateUserByUuid builder with application/json body
func NewUpdateUserByUuidRequest(server string, uuid string, body UpdateUserByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserByUuidRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateUserByUuidRequestWithBody generates requests for UpdateUserByUuid with any type of body
func NewUpdateUserByUuidRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/users/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListPersistentVolumesRequest generates requests for ListPersistentVolumes
func NewListPersistentVolumesRequest(server string, params *ListPersistentVolumesParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/volumes"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.PageNum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageNum", *params.PageNum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageSize", *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortType != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortType", *params.SortType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortField != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortField", *params.SortField); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClusterDatabaseVolumesRequest generates requests for ListClusterDatabaseVolumes
func NewListClusterDatabaseVolumesRequest(server string, clusterUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/volumes/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListImagesRequest generates requests for ListImages
func NewListImagesRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/webserver/images"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImageByUuidRequest generates requests for GetImageByUuid
func NewGetImageByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/webserver/images/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOfferingsRequest generates requests for ListOfferings
func NewListOfferingsRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/webserver/offerings"))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOfferingByUuidRequest generates requests for GetOfferingByUuid
func NewGetOfferingByUuidRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/webserver/offerings/%s", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkNodesRequest generates requests for ListWorkNodes
func NewListWorkNodesRequest(server string, params *ListWorkNodesParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/work_node"))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sort_by", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDrainNodeByNodeNameRequest generates requests for DrainNodeByNodeName
func NewDrainNodeByNodeNameRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "node_name", nodeName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/work_node/%s/drain", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNodeResourceRequest generates requests for GetNodeResource
func NewGetNodeResourceRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "node_name", nodeName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/work_node/%s/resource", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUncordonNodeByNodeNameRequest generates requests for UncordonNodeByNodeName
func NewUncordonNodeByNodeNameRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "node_name", nodeName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/work_node/%s/uncordon", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBackupsRequest generates requests for ListBackups
func NewListBackupsRequest(server string, clusterType ClusterType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/backups", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBackupSetByUuidRequest generates requests for DeleteBackupSetByUuid
func NewDeleteBackupSetByUuidRequest(server string, clusterType ClusterType, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/backups/backup_sets/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClusterBackupSetsRequest generates requests for ListClusterBackupSets
func NewListClusterBackupSetsRequest(server string, clusterType ClusterType, params *ListClusterBackupSetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/backups/cluster/backup_sets", pathParam0))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageSize", *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageNum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageNum", *params.PageNum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "startTime", *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "endTime", *params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ClusterUuid != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "clusterUuid", *params.ClusterUuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupsByClusterUuidRequest generates requests for GetBackupsByClusterUuid
func NewGetBackupsByClusterUuidRequest(server string, clusterType ClusterType, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/backups/clusters/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFullBackupJobRequest calls the generic CreateFullBackupJob builder with application/json body
func NewCreateFullBackupJobRequest(server string, clusterType ClusterType, body CreateFullBackupJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFullBackupJobRequestWithBody(server, clusterType, "application/json", bodyReader)
}

// NewCreateFullBackupJobRequestWithBody generates requests for CreateFullBackupJob with any type of body
func NewCreateFullBackupJobRequestWithBody(server string, clusterType ClusterType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/backups/full_backup_jobs", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewCreateRestoresRequest calls the generic CreateRestores builder with application/json body
func NewCreateRestoresRequest(server string, clusterType ClusterType, body CreateRestoresJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRestoresRequestWithBody(server, clusterType, "application/json", bodyReader)
}

// NewCreateRestoresRequestWithBody generates requests for CreateRestores with any type of body
func NewCreateRestoresRequestWithBody(server string, clusterType ClusterType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/backups/restores", pathParam0))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListBackupSetsRequest generates requests for ListBackupSets
func NewListBackupSetsRequest(server string, clusterType ClusterType, backupUuid string, params *ListBackupSetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "backup_uuid", backupUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/backups/%s/backup_sets", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.PointInTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pointInTime", *params.PointInTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupsByUuidRequest generates requests for GetBackupsByUuid
func NewGetBackupsByUuidRequest(server string, clusterType ClusterType, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/backups/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBackupByUuidRequest calls the generic UpdateBackupByUuid builder with application/json body
func NewUpdateBackupByUuidRequest(server string, clusterType ClusterType, uuid string, body UpdateBackupByUuidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBackupByUuidRequestWithBody(server, clusterType, uuid, "application/json", bodyReader)
}

// NewUpdateBackupByUuidRequestWithBody generates requests for UpdateBackupByUuid with any type of body
func NewUpdateBackupByUuidRequestWithBody(server string, clusterType ClusterType, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/backups/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListDatabaseAccountRequest generates requests for ListDatabaseAccount
func NewListDatabaseAccountRequest(server string, clusterType ClusterType, clusterUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/clusters/%s/database_accounts", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabaseAccountRequest calls the generic CreateDatabaseAccount builder with application/json body
func NewCreateDatabaseAccountRequest(server string, clusterType ClusterType, clusterUuid string, body CreateDatabaseAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseAccountRequestWithBody(server, clusterType, clusterUuid, "application/json", bodyReader)
}

// NewCreateDatabaseAccountRequestWithBody generates requests for CreateDatabaseAccount with any type of body
func NewCreateDatabaseAccountRequestWithBody(server string, clusterType ClusterType, clusterUuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/clusters/%s/database_accounts", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteDatabaseAccountByUuidRequest generates requests for DeleteDatabaseAccountByUuid
func NewDeleteDatabaseAccountByUuidRequest(server string, clusterType ClusterType, clusterUuid string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/clusters/%s/database_accounts/%s", pathParam0, pathParam1, pathParam2))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatabaseAccountRequest calls the generic UpdateDatabaseAccount builder with application/json body
func NewUpdateDatabaseAccountRequest(server string, clusterType ClusterType, clusterUuid string, uuid string, body UpdateDatabaseAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatabaseAccountRequestWithBody(server, clusterType, clusterUuid, uuid, "application/json", bodyReader)
}

// NewUpdateDatabaseAccountRequestWithBody generates requests for UpdateDatabaseAccount with any type of body
func NewUpdateDatabaseAccountRequestWithBody(server string, clusterType ClusterType, clusterUuid string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/clusters/%s/database_accounts/%s", pathParam0, pathParam1, pathParam2))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListClusterDatabaseInstancesRequest generates requests for ListClusterDatabaseInstances
func NewListClusterDatabaseInstancesRequest(server string, clusterType ClusterType, clusterUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "cluster_uuid", clusterUuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/clusters/%s/database_instances", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseInstacneByUuidRequest generates requests for GetDatabaseInstacneByUuid
func NewGetDatabaseInstacneByUuidRequest(server string, clusterType ClusterType, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cluster_type", clusterType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/database_instances/%s", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewForbidInstanceRequest generates requests for ForbidInstance
func NewForbidInstanceRequest(server string, engine string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "engine", engine)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}
	queryUrl, err = queryUrl.Parse(fmt.Sprintf("/api/v1/%s/database_instances/%s/forbid_instances", pathParam0, pathParam1))
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		if !strings.HasSuffix(baseURL, "/") {
			baseURL += "/"
		}
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

type listStorageInterfaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]BackupStorageInterface `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listStorageInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listStorageInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createStorageInterfaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *BackupStorageInterface `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createStorageInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createStorageInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteBackupByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r deleteBackupByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteBackupByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getStorageInterfaceByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *BackupStorageInterface `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getStorageInterfaceByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getStorageInterfaceByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getStorageInterfaceStatusByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *BackupStorageInterfaceStatus `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getStorageInterfaceStatusByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getStorageInterfaceStatusByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listClusterWhitelistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *WhiteListPage `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listClusterWhitelistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listClusterWhitelistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createClusterWhitelistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createClusterWhitelistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createClusterWhitelistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteClusterWhitelistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r deleteClusterWhitelistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteClusterWhitelistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateClusterWhitelistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateClusterWhitelistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateClusterWhitelistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createContainerShellResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r createContainerShellResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createContainerShellResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listDatabaseTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/Page)
			Page
			// Embedded fields due to inline allOf schema
			Items *[]DatabaseTarget `json:"items,omitempty"`
		} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listDatabaseTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listDatabaseTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createDatabaseTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *DatabaseTarget `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createDatabaseTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createDatabaseTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type validateMonitorUserPrivilegeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *DatabasePrivilegeValidation `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r validateMonitorUserPrivilegeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r validateMonitorUserPrivilegeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteDatabaseTargetByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r deleteDatabaseTargetByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteDatabaseTargetByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getDatabaseTargetByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *DatabaseTarget `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getDatabaseTargetByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getDatabaseTargetByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateDatabaseTargetByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *DatabaseTarget `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateDatabaseTargetByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateDatabaseTargetByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getDatetimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *string `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getDatetimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getDatetimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateDatetimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *string `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r updateDatetimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateDatetimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listEventPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/Page)
			Page
			// Embedded fields due to inline allOf schema
			Items *[]Event `json:"items,omitempty"`
		} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listEventPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listEventPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			Items *[]Network `json:"items,omitempty"`
		} `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r listNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *Network `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleleNetworkAddressByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r deleleNetworkAddressByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleleNetworkAddressByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteNewtorkByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r deleteNewtorkByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteNewtorkByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createNetworkAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *NetworkAddress `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r createNetworkAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createNetworkAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createVIPValiationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			Ok     *bool   `json:"ok,omitempty"`
			Reason *string `json:"reason,omitempty"`
		} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createVIPValiationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createVIPValiationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getK8sResourceOverviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *K8sResourceOverview `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getK8sResourceOverviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getK8sResourceOverviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *LicenseInfo `json:"data,omitempty"`
	}
	JSON201 *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *string `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type loginUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *User `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r loginUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r loginUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMySQLAggregatedSlowQueryLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/Page)
			Page
			// Embedded fields due to inline allOf schema
			Items *[]AggregatedSlowQueryLog `json:"items,omitempty"`
		} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMySQLAggregatedSlowQueryLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMySQLAggregatedSlowQueryLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMySQLErrorLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/Page)
			Page
			// Embedded fields due to inline allOf schema
			Items *[]MySQLErrorLog `json:"items,omitempty"`
		} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMySQLErrorLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMySQLErrorLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMySQLSlowQueryLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/Page)
			Page
			// Embedded fields due to inline allOf schema
			Items *[]SlowQueryLog `json:"items,omitempty"`
		} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMySQLSlowQueryLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMySQLSlowQueryLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMssqlClsutersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]MssqlClusterOverview `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMssqlClsutersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMssqlClsutersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createMssqlClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createMssqlClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createMssqlClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMssqlSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]DatabaseSchema `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMssqlSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMssqlSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createMssqlSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createMssqlSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createMssqlSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteMssqlSchemaByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r deleteMssqlSchemaByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteMssqlSchemaByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteMssqlClusterByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r deleteMssqlClusterByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteMssqlClusterByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getMssqlClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]MssqlClusterOverview `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getMssqlClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getMssqlClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateMssqlClusterByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateMssqlClusterByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateMssqlClusterByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMysqlClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]MysqlClusterOverview `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMysqlClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMysqlClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createMysqlClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createMysqlClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createMysqlClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMysqlClusterConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]MysqlClusterConfig `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMysqlClusterConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMysqlClusterConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateMysqlClusterConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateMysqlClusterConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateMysqlClusterConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMysqlDatabaseSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]DatabaseSchema `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMysqlDatabaseSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMysqlDatabaseSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createMysqlSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *DatabaseSchema `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createMysqlSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createMysqlSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteMysqlSchemaByUuuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r deleteMysqlSchemaByUuuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteMysqlSchemaByUuuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getMysqlDatabaseTopologyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *MysqlClusterTopology `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getMysqlDatabaseTopologyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getMysqlDatabaseTopologyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteMysqlClsuterByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r deleteMysqlClsuterByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteMysqlClsuterByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getClusterByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]MysqlClusterOverview `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getClusterByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getClusterByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateClusterByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateClusterByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateClusterByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMysqlConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]MysqlDatabaseConfig `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMysqlConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMysqlConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createMysqlConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createMysqlConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createMysqlConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteMysqlConfigByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r deleteMysqlConfigByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteMysqlConfigByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateMysqlConfigByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateMysqlConfigByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateMysqlConfigByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createRecreatedInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createRecreatedInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createRecreatedInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMySQLAuditLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/Page)
			Page
			// Embedded fields due to inline allOf schema
			Items *[]MySQLAuditLog `json:"items,omitempty"`
		} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMySQLAuditLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMySQLAuditLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMySQLSwitchMasterLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/Page)
			Page
			// Embedded fields due to inline allOf schema
			Items *[]MySQLSwitchMasterLog `json:"items,omitempty"`
		} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMySQLSwitchMasterLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMySQLSwitchMasterLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMysqlProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]MysqlProxy `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMysqlProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMysqlProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createMysqlProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createMysqlProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createMysqlProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteMysqlProxyByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r deleteMysqlProxyByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteMysqlProxyByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMysqlProxyBuClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]MysqlProxy `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMysqlProxyBuClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMysqlProxyBuClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateMySQLProxyByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateMySQLProxyByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateMySQLProxyByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listMysqlProxyAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]DatabaseAccount `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listMysqlProxyAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listMysqlProxyAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createMysqlProxyAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createMysqlProxyAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createMysqlProxyAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateMysqlProxyAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateMysqlProxyAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateMysqlProxyAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteMyqlProxyAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r deleteMyqlProxyAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteMyqlProxyAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getMysqlSlowQueryLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]MysqlSlowQueryLog `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getMysqlSlowQueryLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getMysqlSlowQueryLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]Namespace `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listOracleClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]OracleClusterOverview `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listOracleClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listOracleClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createOracleClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createOracleClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createOracleClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateOracleAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateOracleAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateOracleAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listOracleSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]OracleSchema `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listOracleSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listOracleSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteOracleClusterByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r deleteOracleClusterByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteOracleClusterByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getOracleClusterByUuiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]OracleClusterOverview `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getOracleClusterByUuiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getOracleClusterByUuiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateOracleClusterByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateOracleClusterByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateOracleClusterByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listOracleAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]OracleAccount `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listOracleAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listOracleAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getClusterOverviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *ClusterResourceOverview `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getClusterOverviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getClusterOverviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createDepartmentReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r createDepartmentReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createDepartmentReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createSystemReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r createSystemReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createSystemReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listStorageClassesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]StorageClass `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r listStorageClassesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listStorageClassesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type putApiV1TagClusterUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r putApiV1TagClusterUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r putApiV1TagClusterUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]UserList `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteUserByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r deleteUserByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteUserByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateUserByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateUserByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateUserByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listPersistentVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/Page)
			Page
			// Embedded struct due to allOf(#/components/schemas/StorageClass)
			StorageClass
			// Embedded fields due to inline allOf schema
			Items *[]PersistentVolume `json:"items,omitempty"`
		} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listPersistentVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listPersistentVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listClusterDatabaseVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]DatabaseVolume `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listClusterDatabaseVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listClusterDatabaseVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]Image `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getImageByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *Image `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getImageByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getImageByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listOfferingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]Offering `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listOfferingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listOfferingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getOfferingByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *Offering `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getOfferingByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getOfferingByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listWorkNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]WorkNode `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listWorkNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listWorkNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type drainNodeByNodeNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *string `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r drainNodeByNodeNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r drainNodeByNodeNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getNodeResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *WorkNodeResource `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getNodeResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getNodeResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type uncordonNodeByNodeNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *string `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r uncordonNodeByNodeNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r uncordonNodeByNodeNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]Backup `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteBackupSetByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r deleteBackupSetByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteBackupSetByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listClusterBackupSetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *struct {
			// Embedded struct due to allOf(#/components/schemas/Page)
			Page
			// Embedded fields due to inline allOf schema
			Items *[]BackupSet `json:"items,omitempty"`
		} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listClusterBackupSetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listClusterBackupSetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getBackupsByClusterUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *Backup `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getBackupsByClusterUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getBackupsByClusterUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createFullBackupJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createFullBackupJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createFullBackupJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createRestoresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *DatabaseRestoreRequest `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createRestoresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createRestoresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listBackupSetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]BackupSet `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listBackupSetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listBackupSetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getBackupsByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *Backup `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r getBackupsByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getBackupsByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateBackupByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *Backup `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateBackupByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateBackupByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listDatabaseAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]DatabaseAccount `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listDatabaseAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listDatabaseAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createDatabaseAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r createDatabaseAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createDatabaseAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteDatabaseAccountByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r deleteDatabaseAccountByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteDatabaseAccountByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateDatabaseAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r updateDatabaseAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateDatabaseAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type listClusterDatabaseInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *[]DatabaseInstanceDetail `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r listClusterDatabaseInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r listClusterDatabaseInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getDatabaseInstacneByUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *DatabaseInstance `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getDatabaseInstacneByUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getDatabaseInstacneByUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type forbidInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/Response)
		Response
		// Embedded fields due to inline allOf schema
		Data *map[string]interface{} `json:"data,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r forbidInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r forbidInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListStorageInterfaceWithResponse request returning *ListStorageInterfaceResponse
func (c *ClientWithResponses) ListStorageInterfaceWithResponse(ctx context.Context) (*listStorageInterfaceResponse, error) {
	rsp, err := c.ListStorageInterface(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListStorageInterfaceResponse(rsp)
}

// CreateStorageInterfaceWithBodyWithResponse request with arbitrary body returning *CreateStorageInterfaceResponse
func (c *ClientWithResponses) CreateStorageInterfaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createStorageInterfaceResponse, error) {
	rsp, err := c.CreateStorageInterfaceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageInterfaceResponse(rsp)
}

func (c *ClientWithResponses) CreateStorageInterfaceWithResponse(ctx context.Context, body CreateStorageInterfaceJSONRequestBody) (*createStorageInterfaceResponse, error) {
	rsp, err := c.CreateStorageInterface(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageInterfaceResponse(rsp)
}

// DeleteBackupByUuidWithResponse request returning *DeleteBackupByUuidResponse
func (c *ClientWithResponses) DeleteBackupByUuidWithResponse(ctx context.Context, uuid string) (*deleteBackupByUuidResponse, error) {
	rsp, err := c.DeleteBackupByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackupByUuidResponse(rsp)
}

// GetStorageInterfaceByUuidWithBodyWithResponse request with arbitrary body returning *GetStorageInterfaceByUuidResponse
func (c *ClientWithResponses) GetStorageInterfaceByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*getStorageInterfaceByUuidResponse, error) {
	rsp, err := c.GetStorageInterfaceByUuidWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageInterfaceByUuidResponse(rsp)
}

func (c *ClientWithResponses) GetStorageInterfaceByUuidWithResponse(ctx context.Context, uuid string, body GetStorageInterfaceByUuidJSONRequestBody) (*getStorageInterfaceByUuidResponse, error) {
	rsp, err := c.GetStorageInterfaceByUuid(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageInterfaceByUuidResponse(rsp)
}

// GetStorageInterfaceStatusByUuidWithResponse request returning *GetStorageInterfaceStatusByUuidResponse
func (c *ClientWithResponses) GetStorageInterfaceStatusByUuidWithResponse(ctx context.Context, uuid string) (*getStorageInterfaceStatusByUuidResponse, error) {
	rsp, err := c.GetStorageInterfaceStatusByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageInterfaceStatusByUuidResponse(rsp)
}

// ListClusterWhitelistWithResponse request returning *ListClusterWhitelistResponse
func (c *ClientWithResponses) ListClusterWhitelistWithResponse(ctx context.Context, clusterUuid string, params *ListClusterWhitelistParams) (*listClusterWhitelistResponse, error) {
	rsp, err := c.ListClusterWhitelist(ctx, clusterUuid, params)
	if err != nil {
		return nil, err
	}
	return ParseListClusterWhitelistResponse(rsp)
}

// CreateClusterWhitelistWithBodyWithResponse request with arbitrary body returning *CreateClusterWhitelistResponse
func (c *ClientWithResponses) CreateClusterWhitelistWithBodyWithResponse(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*createClusterWhitelistResponse, error) {
	rsp, err := c.CreateClusterWhitelistWithBody(ctx, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterWhitelistResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWhitelistWithResponse(ctx context.Context, clusterUuid string, body CreateClusterWhitelistJSONRequestBody) (*createClusterWhitelistResponse, error) {
	rsp, err := c.CreateClusterWhitelist(ctx, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterWhitelistResponse(rsp)
}

// DeleteClusterWhitelistWithResponse request returning *DeleteClusterWhitelistResponse
func (c *ClientWithResponses) DeleteClusterWhitelistWithResponse(ctx context.Context, clusterUuid string, uuid string) (*deleteClusterWhitelistResponse, error) {
	rsp, err := c.DeleteClusterWhitelist(ctx, clusterUuid, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterWhitelistResponse(rsp)
}

// UpdateClusterWhitelistWithBodyWithResponse request with arbitrary body returning *UpdateClusterWhitelistResponse
func (c *ClientWithResponses) UpdateClusterWhitelistWithBodyWithResponse(ctx context.Context, clusterUuid string, uuid string, params *UpdateClusterWhitelistParams, contentType string, body io.Reader) (*updateClusterWhitelistResponse, error) {
	rsp, err := c.UpdateClusterWhitelistWithBody(ctx, clusterUuid, uuid, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterWhitelistResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWhitelistWithResponse(ctx context.Context, clusterUuid string, uuid string, params *UpdateClusterWhitelistParams, body UpdateClusterWhitelistJSONRequestBody) (*updateClusterWhitelistResponse, error) {
	rsp, err := c.UpdateClusterWhitelist(ctx, clusterUuid, uuid, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterWhitelistResponse(rsp)
}

// CreateContainerShellWithResponse request returning *CreateContainerShellResponse
func (c *ClientWithResponses) CreateContainerShellWithResponse(ctx context.Context, params *CreateContainerShellParams) (*createContainerShellResponse, error) {
	rsp, err := c.CreateContainerShell(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerShellResponse(rsp)
}

// ListDatabaseTargetWithResponse request returning *ListDatabaseTargetResponse
func (c *ClientWithResponses) ListDatabaseTargetWithResponse(ctx context.Context) (*listDatabaseTargetResponse, error) {
	rsp, err := c.ListDatabaseTarget(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListDatabaseTargetResponse(rsp)
}

// CreateDatabaseTargetWithBodyWithResponse request with arbitrary body returning *CreateDatabaseTargetResponse
func (c *ClientWithResponses) CreateDatabaseTargetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createDatabaseTargetResponse, error) {
	rsp, err := c.CreateDatabaseTargetWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseTargetResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseTargetWithResponse(ctx context.Context, body CreateDatabaseTargetJSONRequestBody) (*createDatabaseTargetResponse, error) {
	rsp, err := c.CreateDatabaseTarget(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseTargetResponse(rsp)
}

// ValidateMonitorUserPrivilegeWithBodyWithResponse request with arbitrary body returning *ValidateMonitorUserPrivilegeResponse
func (c *ClientWithResponses) ValidateMonitorUserPrivilegeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*validateMonitorUserPrivilegeResponse, error) {
	rsp, err := c.ValidateMonitorUserPrivilegeWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseValidateMonitorUserPrivilegeResponse(rsp)
}

func (c *ClientWithResponses) ValidateMonitorUserPrivilegeWithResponse(ctx context.Context, body ValidateMonitorUserPrivilegeJSONRequestBody) (*validateMonitorUserPrivilegeResponse, error) {
	rsp, err := c.ValidateMonitorUserPrivilege(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseValidateMonitorUserPrivilegeResponse(rsp)
}

// DeleteDatabaseTargetByUuidWithResponse request returning *DeleteDatabaseTargetByUuidResponse
func (c *ClientWithResponses) DeleteDatabaseTargetByUuidWithResponse(ctx context.Context, uuid string) (*deleteDatabaseTargetByUuidResponse, error) {
	rsp, err := c.DeleteDatabaseTargetByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatabaseTargetByUuidResponse(rsp)
}

// GetDatabaseTargetByUuidWithResponse request returning *GetDatabaseTargetByUuidResponse
func (c *ClientWithResponses) GetDatabaseTargetByUuidWithResponse(ctx context.Context, uuid string) (*getDatabaseTargetByUuidResponse, error) {
	rsp, err := c.GetDatabaseTargetByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseTargetByUuidResponse(rsp)
}

// UpdateDatabaseTargetByUuidWithBodyWithResponse request with arbitrary body returning *UpdateDatabaseTargetByUuidResponse
func (c *ClientWithResponses) UpdateDatabaseTargetByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*updateDatabaseTargetByUuidResponse, error) {
	rsp, err := c.UpdateDatabaseTargetByUuidWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseTargetByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatabaseTargetByUuidWithResponse(ctx context.Context, uuid string, body UpdateDatabaseTargetByUuidJSONRequestBody) (*updateDatabaseTargetByUuidResponse, error) {
	rsp, err := c.UpdateDatabaseTargetByUuid(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseTargetByUuidResponse(rsp)
}

// GetDatetimeWithResponse request returning *GetDatetimeResponse
func (c *ClientWithResponses) GetDatetimeWithResponse(ctx context.Context) (*getDatetimeResponse, error) {
	rsp, err := c.GetDatetime(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetDatetimeResponse(rsp)
}

// UpdateDatetimeWithBodyWithResponse request with arbitrary body returning *UpdateDatetimeResponse
func (c *ClientWithResponses) UpdateDatetimeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*updateDatetimeResponse, error) {
	rsp, err := c.UpdateDatetimeWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatetimeResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatetimeWithResponse(ctx context.Context, body UpdateDatetimeJSONRequestBody) (*updateDatetimeResponse, error) {
	rsp, err := c.UpdateDatetime(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatetimeResponse(rsp)
}

// CreateEventWithBodyWithResponse request with arbitrary body returning *CreateEventResponse
func (c *ClientWithResponses) CreateEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createEventResponse, error) {
	rsp, err := c.CreateEventWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateEventResponse(rsp)
}

func (c *ClientWithResponses) CreateEventWithResponse(ctx context.Context, body CreateEventJSONRequestBody) (*createEventResponse, error) {
	rsp, err := c.CreateEvent(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateEventResponse(rsp)
}

// ListEventPageWithResponse request returning *ListEventPageResponse
func (c *ClientWithResponses) ListEventPageWithResponse(ctx context.Context, params *ListEventPageParams) (*listEventPageResponse, error) {
	rsp, err := c.ListEventPage(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListEventPageResponse(rsp)
}

// ListNetworkWithResponse request returning *ListNetworkResponse
func (c *ClientWithResponses) ListNetworkWithResponse(ctx context.Context) (*listNetworkResponse, error) {
	rsp, err := c.ListNetwork(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListNetworkResponse(rsp)
}

// CreateNetworkWithBodyWithResponse request with arbitrary body returning *CreateNetworkResponse
func (c *ClientWithResponses) CreateNetworkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createNetworkResponse, error) {
	rsp, err := c.CreateNetworkWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetworkResponse(rsp)
}

func (c *ClientWithResponses) CreateNetworkWithResponse(ctx context.Context, body CreateNetworkJSONRequestBody) (*createNetworkResponse, error) {
	rsp, err := c.CreateNetwork(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetworkResponse(rsp)
}

// DeleleNetworkAddressByUuidWithResponse request returning *DeleleNetworkAddressByUuidResponse
func (c *ClientWithResponses) DeleleNetworkAddressByUuidWithResponse(ctx context.Context, uuid string) (*deleleNetworkAddressByUuidResponse, error) {
	rsp, err := c.DeleleNetworkAddressByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleleNetworkAddressByUuidResponse(rsp)
}

// DeleteNewtorkByUuidWithResponse request returning *DeleteNewtorkByUuidResponse
func (c *ClientWithResponses) DeleteNewtorkByUuidWithResponse(ctx context.Context, uuid string) (*deleteNewtorkByUuidResponse, error) {
	rsp, err := c.DeleteNewtorkByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNewtorkByUuidResponse(rsp)
}

// CreateNetworkAddressWithBodyWithResponse request with arbitrary body returning *CreateNetworkAddressResponse
func (c *ClientWithResponses) CreateNetworkAddressWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*createNetworkAddressResponse, error) {
	rsp, err := c.CreateNetworkAddressWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetworkAddressResponse(rsp)
}

func (c *ClientWithResponses) CreateNetworkAddressWithResponse(ctx context.Context, uuid string, body CreateNetworkAddressJSONRequestBody) (*createNetworkAddressResponse, error) {
	rsp, err := c.CreateNetworkAddress(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetworkAddressResponse(rsp)
}

// CreateVIPValiationWithResponse request returning *CreateVIPValiationResponse
func (c *ClientWithResponses) CreateVIPValiationWithResponse(ctx context.Context, ip string) (*createVIPValiationResponse, error) {
	rsp, err := c.CreateVIPValiation(ctx, ip)
	if err != nil {
		return nil, err
	}
	return ParseCreateVIPValiationResponse(rsp)
}

// GetK8sResourceOverviewWithResponse request returning *GetK8sResourceOverviewResponse
func (c *ClientWithResponses) GetK8sResourceOverviewWithResponse(ctx context.Context) (*getK8sResourceOverviewResponse, error) {
	rsp, err := c.GetK8sResourceOverview(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetK8sResourceOverviewResponse(rsp)
}

// GetLicenseWithResponse request returning *GetLicenseResponse
func (c *ClientWithResponses) GetLicenseWithResponse(ctx context.Context, params *GetLicenseParams) (*getLicenseResponse, error) {
	rsp, err := c.GetLicense(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseResponse(rsp)
}

// UpdateLicenseWithBodyWithResponse request with arbitrary body returning *UpdateLicenseResponse
func (c *ClientWithResponses) UpdateLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*updateLicenseResponse, error) {
	rsp, err := c.UpdateLicenseWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLicenseResponse(rsp)
}

func (c *ClientWithResponses) UpdateLicenseWithResponse(ctx context.Context, body UpdateLicenseJSONRequestBody) (*updateLicenseResponse, error) {
	rsp, err := c.UpdateLicense(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLicenseResponse(rsp)
}

// LoginUserWithBodyWithResponse request with arbitrary body returning *LoginUserResponse
func (c *ClientWithResponses) LoginUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*loginUserResponse, error) {
	rsp, err := c.LoginUserWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseLoginUserResponse(rsp)
}

func (c *ClientWithResponses) LoginUserWithResponse(ctx context.Context, body LoginUserJSONRequestBody) (*loginUserResponse, error) {
	rsp, err := c.LoginUser(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseLoginUserResponse(rsp)
}

// ListMySQLAggregatedSlowQueryLogWithResponse request returning *ListMySQLAggregatedSlowQueryLogResponse
func (c *ClientWithResponses) ListMySQLAggregatedSlowQueryLogWithResponse(ctx context.Context, params *ListMySQLAggregatedSlowQueryLogParams) (*listMySQLAggregatedSlowQueryLogResponse, error) {
	rsp, err := c.ListMySQLAggregatedSlowQueryLog(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListMySQLAggregatedSlowQueryLogResponse(rsp)
}

// ListMySQLErrorLogWithResponse request returning *ListMySQLErrorLogResponse
func (c *ClientWithResponses) ListMySQLErrorLogWithResponse(ctx context.Context, params *ListMySQLErrorLogParams) (*listMySQLErrorLogResponse, error) {
	rsp, err := c.ListMySQLErrorLog(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListMySQLErrorLogResponse(rsp)
}

// ListMySQLSlowQueryLogWithResponse request returning *ListMySQLSlowQueryLogResponse
func (c *ClientWithResponses) ListMySQLSlowQueryLogWithResponse(ctx context.Context, params *ListMySQLSlowQueryLogParams) (*listMySQLSlowQueryLogResponse, error) {
	rsp, err := c.ListMySQLSlowQueryLog(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListMySQLSlowQueryLogResponse(rsp)
}

// ListMssqlClsutersWithResponse request returning *ListMssqlClsutersResponse
func (c *ClientWithResponses) ListMssqlClsutersWithResponse(ctx context.Context, params *ListMssqlClsutersParams) (*listMssqlClsutersResponse, error) {
	rsp, err := c.ListMssqlClsuters(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListMssqlClsutersResponse(rsp)
}

// CreateMssqlClusterWithBodyWithResponse request with arbitrary body returning *CreateMssqlClusterResponse
func (c *ClientWithResponses) CreateMssqlClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createMssqlClusterResponse, error) {
	rsp, err := c.CreateMssqlClusterWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMssqlClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateMssqlClusterWithResponse(ctx context.Context, body CreateMssqlClusterJSONRequestBody) (*createMssqlClusterResponse, error) {
	rsp, err := c.CreateMssqlCluster(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMssqlClusterResponse(rsp)
}

// ListMssqlSchemaWithResponse request returning *ListMssqlSchemaResponse
func (c *ClientWithResponses) ListMssqlSchemaWithResponse(ctx context.Context, clusterUuid string) (*listMssqlSchemaResponse, error) {
	rsp, err := c.ListMssqlSchema(ctx, clusterUuid)
	if err != nil {
		return nil, err
	}
	return ParseListMssqlSchemaResponse(rsp)
}

// CreateMssqlSchemaWithBodyWithResponse request with arbitrary body returning *CreateMssqlSchemaResponse
func (c *ClientWithResponses) CreateMssqlSchemaWithBodyWithResponse(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*createMssqlSchemaResponse, error) {
	rsp, err := c.CreateMssqlSchemaWithBody(ctx, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMssqlSchemaResponse(rsp)
}

func (c *ClientWithResponses) CreateMssqlSchemaWithResponse(ctx context.Context, clusterUuid string, body CreateMssqlSchemaJSONRequestBody) (*createMssqlSchemaResponse, error) {
	rsp, err := c.CreateMssqlSchema(ctx, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMssqlSchemaResponse(rsp)
}

// DeleteMssqlSchemaByUuidWithResponse request returning *DeleteMssqlSchemaByUuidResponse
func (c *ClientWithResponses) DeleteMssqlSchemaByUuidWithResponse(ctx context.Context, clusterUuid string, uuid string) (*deleteMssqlSchemaByUuidResponse, error) {
	rsp, err := c.DeleteMssqlSchemaByUuid(ctx, clusterUuid, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMssqlSchemaByUuidResponse(rsp)
}

// DeleteMssqlClusterByUuidWithResponse request returning *DeleteMssqlClusterByUuidResponse
func (c *ClientWithResponses) DeleteMssqlClusterByUuidWithResponse(ctx context.Context, uuid string, params *DeleteMssqlClusterByUuidParams) (*deleteMssqlClusterByUuidResponse, error) {
	rsp, err := c.DeleteMssqlClusterByUuid(ctx, uuid, params)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMssqlClusterByUuidResponse(rsp)
}

// GetMssqlClusterWithResponse request returning *GetMssqlClusterResponse
func (c *ClientWithResponses) GetMssqlClusterWithResponse(ctx context.Context, uuid string) (*getMssqlClusterResponse, error) {
	rsp, err := c.GetMssqlCluster(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseGetMssqlClusterResponse(rsp)
}

// UpdateMssqlClusterByUuidWithBodyWithResponse request with arbitrary body returning *UpdateMssqlClusterByUuidResponse
func (c *ClientWithResponses) UpdateMssqlClusterByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*updateMssqlClusterByUuidResponse, error) {
	rsp, err := c.UpdateMssqlClusterByUuidWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMssqlClusterByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateMssqlClusterByUuidWithResponse(ctx context.Context, uuid string, body UpdateMssqlClusterByUuidJSONRequestBody) (*updateMssqlClusterByUuidResponse, error) {
	rsp, err := c.UpdateMssqlClusterByUuid(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMssqlClusterByUuidResponse(rsp)
}

// ListMysqlClusterWithResponse request returning *ListMysqlClusterResponse
func (c *ClientWithResponses) ListMysqlClusterWithResponse(ctx context.Context, params *ListMysqlClusterParams) (*listMysqlClusterResponse, error) {
	rsp, err := c.ListMysqlCluster(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListMysqlClusterResponse(rsp)
}

// CreateMysqlClusterWithBodyWithResponse request with arbitrary body returning *CreateMysqlClusterResponse
func (c *ClientWithResponses) CreateMysqlClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createMysqlClusterResponse, error) {
	rsp, err := c.CreateMysqlClusterWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMysqlClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateMysqlClusterWithResponse(ctx context.Context, body CreateMysqlClusterJSONRequestBody) (*createMysqlClusterResponse, error) {
	rsp, err := c.CreateMysqlCluster(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMysqlClusterResponse(rsp)
}

// ListMysqlClusterConfigWithResponse request returning *ListMysqlClusterConfigResponse
func (c *ClientWithResponses) ListMysqlClusterConfigWithResponse(ctx context.Context, clusterUuid string) (*listMysqlClusterConfigResponse, error) {
	rsp, err := c.ListMysqlClusterConfig(ctx, clusterUuid)
	if err != nil {
		return nil, err
	}
	return ParseListMysqlClusterConfigResponse(rsp)
}

// UpdateMysqlClusterConfigWithBodyWithResponse request with arbitrary body returning *UpdateMysqlClusterConfigResponse
func (c *ClientWithResponses) UpdateMysqlClusterConfigWithBodyWithResponse(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*updateMysqlClusterConfigResponse, error) {
	rsp, err := c.UpdateMysqlClusterConfigWithBody(ctx, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMysqlClusterConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateMysqlClusterConfigWithResponse(ctx context.Context, clusterUuid string, body UpdateMysqlClusterConfigJSONRequestBody) (*updateMysqlClusterConfigResponse, error) {
	rsp, err := c.UpdateMysqlClusterConfig(ctx, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMysqlClusterConfigResponse(rsp)
}

// ListMysqlDatabaseSchemasWithResponse request returning *ListMysqlDatabaseSchemasResponse
func (c *ClientWithResponses) ListMysqlDatabaseSchemasWithResponse(ctx context.Context, clusterUuid string) (*listMysqlDatabaseSchemasResponse, error) {
	rsp, err := c.ListMysqlDatabaseSchemas(ctx, clusterUuid)
	if err != nil {
		return nil, err
	}
	return ParseListMysqlDatabaseSchemasResponse(rsp)
}

// CreateMysqlSchemaWithBodyWithResponse request with arbitrary body returning *CreateMysqlSchemaResponse
func (c *ClientWithResponses) CreateMysqlSchemaWithBodyWithResponse(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*createMysqlSchemaResponse, error) {
	rsp, err := c.CreateMysqlSchemaWithBody(ctx, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMysqlSchemaResponse(rsp)
}

func (c *ClientWithResponses) CreateMysqlSchemaWithResponse(ctx context.Context, clusterUuid string, body CreateMysqlSchemaJSONRequestBody) (*createMysqlSchemaResponse, error) {
	rsp, err := c.CreateMysqlSchema(ctx, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMysqlSchemaResponse(rsp)
}

// DeleteMysqlSchemaByUuuidWithResponse request returning *DeleteMysqlSchemaByUuuidResponse
func (c *ClientWithResponses) DeleteMysqlSchemaByUuuidWithResponse(ctx context.Context, clusterUuid string, schemaUuid string) (*deleteMysqlSchemaByUuuidResponse, error) {
	rsp, err := c.DeleteMysqlSchemaByUuuid(ctx, clusterUuid, schemaUuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMysqlSchemaByUuuidResponse(rsp)
}

// GetMysqlDatabaseTopologyWithResponse request returning *GetMysqlDatabaseTopologyResponse
func (c *ClientWithResponses) GetMysqlDatabaseTopologyWithResponse(ctx context.Context, clusterUuid string) (*getMysqlDatabaseTopologyResponse, error) {
	rsp, err := c.GetMysqlDatabaseTopology(ctx, clusterUuid)
	if err != nil {
		return nil, err
	}
	return ParseGetMysqlDatabaseTopologyResponse(rsp)
}

// DeleteMysqlClsuterByUuidWithResponse request returning *DeleteMysqlClsuterByUuidResponse
func (c *ClientWithResponses) DeleteMysqlClsuterByUuidWithResponse(ctx context.Context, uuid string, params *DeleteMysqlClsuterByUuidParams) (*deleteMysqlClsuterByUuidResponse, error) {
	rsp, err := c.DeleteMysqlClsuterByUuid(ctx, uuid, params)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMysqlClsuterByUuidResponse(rsp)
}

// GetClusterByUuidWithResponse request returning *GetClusterByUuidResponse
func (c *ClientWithResponses) GetClusterByUuidWithResponse(ctx context.Context, uuid string) (*getClusterByUuidResponse, error) {
	rsp, err := c.GetClusterByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterByUuidResponse(rsp)
}

// UpdateClusterByUuidWithBodyWithResponse request with arbitrary body returning *UpdateClusterByUuidResponse
func (c *ClientWithResponses) UpdateClusterByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*updateClusterByUuidResponse, error) {
	rsp, err := c.UpdateClusterByUuidWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterByUuidWithResponse(ctx context.Context, uuid string, body UpdateClusterByUuidJSONRequestBody) (*updateClusterByUuidResponse, error) {
	rsp, err := c.UpdateClusterByUuid(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterByUuidResponse(rsp)
}

// ListMysqlConfigWithResponse request returning *ListMysqlConfigResponse
func (c *ClientWithResponses) ListMysqlConfigWithResponse(ctx context.Context) (*listMysqlConfigResponse, error) {
	rsp, err := c.ListMysqlConfig(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListMysqlConfigResponse(rsp)
}

// CreateMysqlConfigWithBodyWithResponse request with arbitrary body returning *CreateMysqlConfigResponse
func (c *ClientWithResponses) CreateMysqlConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createMysqlConfigResponse, error) {
	rsp, err := c.CreateMysqlConfigWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMysqlConfigResponse(rsp)
}

func (c *ClientWithResponses) CreateMysqlConfigWithResponse(ctx context.Context, body CreateMysqlConfigJSONRequestBody) (*createMysqlConfigResponse, error) {
	rsp, err := c.CreateMysqlConfig(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMysqlConfigResponse(rsp)
}

// DeleteMysqlConfigByUuidWithResponse request returning *DeleteMysqlConfigByUuidResponse
func (c *ClientWithResponses) DeleteMysqlConfigByUuidWithResponse(ctx context.Context, uuid string) (*deleteMysqlConfigByUuidResponse, error) {
	rsp, err := c.DeleteMysqlConfigByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMysqlConfigByUuidResponse(rsp)
}

// UpdateMysqlConfigByUuidWithBodyWithResponse request with arbitrary body returning *UpdateMysqlConfigByUuidResponse
func (c *ClientWithResponses) UpdateMysqlConfigByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*updateMysqlConfigByUuidResponse, error) {
	rsp, err := c.UpdateMysqlConfigByUuidWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMysqlConfigByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateMysqlConfigByUuidWithResponse(ctx context.Context, uuid string, body UpdateMysqlConfigByUuidJSONRequestBody) (*updateMysqlConfigByUuidResponse, error) {
	rsp, err := c.UpdateMysqlConfigByUuid(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMysqlConfigByUuidResponse(rsp)
}

// CreateRecreatedInstanceWithResponse request returning *CreateRecreatedInstanceResponse
func (c *ClientWithResponses) CreateRecreatedInstanceWithResponse(ctx context.Context, uuid string) (*createRecreatedInstanceResponse, error) {
	rsp, err := c.CreateRecreatedInstance(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseCreateRecreatedInstanceResponse(rsp)
}

// ListMySQLAuditLogWithResponse request returning *ListMySQLAuditLogResponse
func (c *ClientWithResponses) ListMySQLAuditLogWithResponse(ctx context.Context, params *ListMySQLAuditLogParams) (*listMySQLAuditLogResponse, error) {
	rsp, err := c.ListMySQLAuditLog(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListMySQLAuditLogResponse(rsp)
}

// ListMySQLSwitchMasterLogWithResponse request returning *ListMySQLSwitchMasterLogResponse
func (c *ClientWithResponses) ListMySQLSwitchMasterLogWithResponse(ctx context.Context, params *ListMySQLSwitchMasterLogParams) (*listMySQLSwitchMasterLogResponse, error) {
	rsp, err := c.ListMySQLSwitchMasterLog(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListMySQLSwitchMasterLogResponse(rsp)
}

// ListMysqlProxyWithResponse request returning *ListMysqlProxyResponse
func (c *ClientWithResponses) ListMysqlProxyWithResponse(ctx context.Context) (*listMysqlProxyResponse, error) {
	rsp, err := c.ListMysqlProxy(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListMysqlProxyResponse(rsp)
}

// CreateMysqlProxyWithBodyWithResponse request with arbitrary body returning *CreateMysqlProxyResponse
func (c *ClientWithResponses) CreateMysqlProxyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createMysqlProxyResponse, error) {
	rsp, err := c.CreateMysqlProxyWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMysqlProxyResponse(rsp)
}

func (c *ClientWithResponses) CreateMysqlProxyWithResponse(ctx context.Context, body CreateMysqlProxyJSONRequestBody) (*createMysqlProxyResponse, error) {
	rsp, err := c.CreateMysqlProxy(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMysqlProxyResponse(rsp)
}

// DeleteMysqlProxyByUuidWithResponse request returning *DeleteMysqlProxyByUuidResponse
func (c *ClientWithResponses) DeleteMysqlProxyByUuidWithResponse(ctx context.Context, uuid string) (*deleteMysqlProxyByUuidResponse, error) {
	rsp, err := c.DeleteMysqlProxyByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMysqlProxyByUuidResponse(rsp)
}

// ListMysqlProxyBuClusterWithResponse request returning *ListMysqlProxyBuClusterResponse
func (c *ClientWithResponses) ListMysqlProxyBuClusterWithResponse(ctx context.Context, uuid string) (*listMysqlProxyBuClusterResponse, error) {
	rsp, err := c.ListMysqlProxyBuCluster(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseListMysqlProxyBuClusterResponse(rsp)
}

// UpdateMySQLProxyByUuidWithBodyWithResponse request with arbitrary body returning *UpdateMySQLProxyByUuidResponse
func (c *ClientWithResponses) UpdateMySQLProxyByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*updateMySQLProxyByUuidResponse, error) {
	rsp, err := c.UpdateMySQLProxyByUuidWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMySQLProxyByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateMySQLProxyByUuidWithResponse(ctx context.Context, uuid string, body UpdateMySQLProxyByUuidJSONRequestBody) (*updateMySQLProxyByUuidResponse, error) {
	rsp, err := c.UpdateMySQLProxyByUuid(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMySQLProxyByUuidResponse(rsp)
}

// ListMysqlProxyAccountsWithResponse request returning *ListMysqlProxyAccountsResponse
func (c *ClientWithResponses) ListMysqlProxyAccountsWithResponse(ctx context.Context, uuid string) (*listMysqlProxyAccountsResponse, error) {
	rsp, err := c.ListMysqlProxyAccounts(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseListMysqlProxyAccountsResponse(rsp)
}

// CreateMysqlProxyAccountWithBodyWithResponse request with arbitrary body returning *CreateMysqlProxyAccountResponse
func (c *ClientWithResponses) CreateMysqlProxyAccountWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*createMysqlProxyAccountResponse, error) {
	rsp, err := c.CreateMysqlProxyAccountWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMysqlProxyAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateMysqlProxyAccountWithResponse(ctx context.Context, uuid string, body CreateMysqlProxyAccountJSONRequestBody) (*createMysqlProxyAccountResponse, error) {
	rsp, err := c.CreateMysqlProxyAccount(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMysqlProxyAccountResponse(rsp)
}

// UpdateMysqlProxyAccountWithBodyWithResponse request with arbitrary body returning *UpdateMysqlProxyAccountResponse
func (c *ClientWithResponses) UpdateMysqlProxyAccountWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*updateMysqlProxyAccountResponse, error) {
	rsp, err := c.UpdateMysqlProxyAccountWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMysqlProxyAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateMysqlProxyAccountWithResponse(ctx context.Context, uuid string, body UpdateMysqlProxyAccountJSONRequestBody) (*updateMysqlProxyAccountResponse, error) {
	rsp, err := c.UpdateMysqlProxyAccount(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMysqlProxyAccountResponse(rsp)
}

// DeleteMyqlProxyAccountWithResponse request returning *DeleteMyqlProxyAccountResponse
func (c *ClientWithResponses) DeleteMyqlProxyAccountWithResponse(ctx context.Context, uuid string, accountName string) (*deleteMyqlProxyAccountResponse, error) {
	rsp, err := c.DeleteMyqlProxyAccount(ctx, uuid, accountName)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMyqlProxyAccountResponse(rsp)
}

// GetMysqlSlowQueryLogWithResponse request returning *GetMysqlSlowQueryLogResponse
func (c *ClientWithResponses) GetMysqlSlowQueryLogWithResponse(ctx context.Context) (*getMysqlSlowQueryLogResponse, error) {
	rsp, err := c.GetMysqlSlowQueryLog(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetMysqlSlowQueryLogResponse(rsp)
}

// ListNamespacesWithResponse request returning *ListNamespacesResponse
func (c *ClientWithResponses) ListNamespacesWithResponse(ctx context.Context) (*listNamespacesResponse, error) {
	rsp, err := c.ListNamespaces(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListNamespacesResponse(rsp)
}

// ListOracleClusterWithResponse request returning *ListOracleClusterResponse
func (c *ClientWithResponses) ListOracleClusterWithResponse(ctx context.Context, params *ListOracleClusterParams) (*listOracleClusterResponse, error) {
	rsp, err := c.ListOracleCluster(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListOracleClusterResponse(rsp)
}

// CreateOracleClusterWithBodyWithResponse request with arbitrary body returning *CreateOracleClusterResponse
func (c *ClientWithResponses) CreateOracleClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createOracleClusterResponse, error) {
	rsp, err := c.CreateOracleClusterWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateOracleClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateOracleClusterWithResponse(ctx context.Context, body CreateOracleClusterJSONRequestBody) (*createOracleClusterResponse, error) {
	rsp, err := c.CreateOracleCluster(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateOracleClusterResponse(rsp)
}

// UpdateOracleAccountWithBodyWithResponse request with arbitrary body returning *UpdateOracleAccountResponse
func (c *ClientWithResponses) UpdateOracleAccountWithBodyWithResponse(ctx context.Context, clusterUuid string, uuid string, contentType string, body io.Reader) (*updateOracleAccountResponse, error) {
	rsp, err := c.UpdateOracleAccountWithBody(ctx, clusterUuid, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOracleAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateOracleAccountWithResponse(ctx context.Context, clusterUuid string, uuid string, body UpdateOracleAccountJSONRequestBody) (*updateOracleAccountResponse, error) {
	rsp, err := c.UpdateOracleAccount(ctx, clusterUuid, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOracleAccountResponse(rsp)
}

// ListOracleSchemasWithResponse request returning *ListOracleSchemasResponse
func (c *ClientWithResponses) ListOracleSchemasWithResponse(ctx context.Context, clusterUuid string) (*listOracleSchemasResponse, error) {
	rsp, err := c.ListOracleSchemas(ctx, clusterUuid)
	if err != nil {
		return nil, err
	}
	return ParseListOracleSchemasResponse(rsp)
}

// DeleteOracleClusterByUuidWithResponse request returning *DeleteOracleClusterByUuidResponse
func (c *ClientWithResponses) DeleteOracleClusterByUuidWithResponse(ctx context.Context, uuid string) (*deleteOracleClusterByUuidResponse, error) {
	rsp, err := c.DeleteOracleClusterByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOracleClusterByUuidResponse(rsp)
}

// GetOracleClusterByUuiWithResponse request returning *GetOracleClusterByUuiResponse
func (c *ClientWithResponses) GetOracleClusterByUuiWithResponse(ctx context.Context, uuid string) (*getOracleClusterByUuiResponse, error) {
	rsp, err := c.GetOracleClusterByUui(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseGetOracleClusterByUuiResponse(rsp)
}

// UpdateOracleClusterByUuidWithBodyWithResponse request with arbitrary body returning *UpdateOracleClusterByUuidResponse
func (c *ClientWithResponses) UpdateOracleClusterByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*updateOracleClusterByUuidResponse, error) {
	rsp, err := c.UpdateOracleClusterByUuidWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOracleClusterByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateOracleClusterByUuidWithResponse(ctx context.Context, uuid string, body UpdateOracleClusterByUuidJSONRequestBody) (*updateOracleClusterByUuidResponse, error) {
	rsp, err := c.UpdateOracleClusterByUuid(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOracleClusterByUuidResponse(rsp)
}

// ListOracleAccountWithResponse request returning *ListOracleAccountResponse
func (c *ClientWithResponses) ListOracleAccountWithResponse(ctx context.Context, clusterUuid string) (*listOracleAccountResponse, error) {
	rsp, err := c.ListOracleAccount(ctx, clusterUuid)
	if err != nil {
		return nil, err
	}
	return ParseListOracleAccountResponse(rsp)
}

// GetClusterOverviewWithResponse request returning *GetClusterOverviewResponse
func (c *ClientWithResponses) GetClusterOverviewWithResponse(ctx context.Context) (*getClusterOverviewResponse, error) {
	rsp, err := c.GetClusterOverview(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterOverviewResponse(rsp)
}

// CreateDepartmentReportWithBodyWithResponse request with arbitrary body returning *CreateDepartmentReportResponse
func (c *ClientWithResponses) CreateDepartmentReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createDepartmentReportResponse, error) {
	rsp, err := c.CreateDepartmentReportWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateDepartmentReportResponse(rsp)
}

func (c *ClientWithResponses) CreateDepartmentReportWithResponse(ctx context.Context, body CreateDepartmentReportJSONRequestBody) (*createDepartmentReportResponse, error) {
	rsp, err := c.CreateDepartmentReport(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateDepartmentReportResponse(rsp)
}

// CreateSystemReportWithBodyWithResponse request with arbitrary body returning *CreateSystemReportResponse
func (c *ClientWithResponses) CreateSystemReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createSystemReportResponse, error) {
	rsp, err := c.CreateSystemReportWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateSystemReportResponse(rsp)
}

func (c *ClientWithResponses) CreateSystemReportWithResponse(ctx context.Context, body CreateSystemReportJSONRequestBody) (*createSystemReportResponse, error) {
	rsp, err := c.CreateSystemReport(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateSystemReportResponse(rsp)
}

// ListStorageClassesWithResponse request returning *ListStorageClassesResponse
func (c *ClientWithResponses) ListStorageClassesWithResponse(ctx context.Context) (*listStorageClassesResponse, error) {
	rsp, err := c.ListStorageClasses(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListStorageClassesResponse(rsp)
}

// PutApiV1TagClusterUuidWithBodyWithResponse request with arbitrary body returning *PutApiV1TagClusterUuidResponse
func (c *ClientWithResponses) PutApiV1TagClusterUuidWithBodyWithResponse(ctx context.Context, clusterUuid string, contentType string, body io.Reader) (*putApiV1TagClusterUuidResponse, error) {
	rsp, err := c.PutApiV1TagClusterUuidWithBody(ctx, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutApiV1TagClusterUuidResponse(rsp)
}

func (c *ClientWithResponses) PutApiV1TagClusterUuidWithResponse(ctx context.Context, clusterUuid string, body PutApiV1TagClusterUuidJSONRequestBody) (*putApiV1TagClusterUuidResponse, error) {
	rsp, err := c.PutApiV1TagClusterUuid(ctx, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	return ParsePutApiV1TagClusterUuidResponse(rsp)
}

// ListUsersWithBodyWithResponse request with arbitrary body returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*listUsersResponse, error) {
	rsp, err := c.ListUsersWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, body ListUsersJSONRequestBody) (*listUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody) (*createUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserByUuidWithResponse request returning *DeleteUserByUuidResponse
func (c *ClientWithResponses) DeleteUserByUuidWithResponse(ctx context.Context, uuid string) (*deleteUserByUuidResponse, error) {
	rsp, err := c.DeleteUserByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserByUuidResponse(rsp)
}

// UpdateUserByUuidWithBodyWithResponse request with arbitrary body returning *UpdateUserByUuidResponse
func (c *ClientWithResponses) UpdateUserByUuidWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader) (*updateUserByUuidResponse, error) {
	rsp, err := c.UpdateUserByUuidWithBody(ctx, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserByUuidWithResponse(ctx context.Context, uuid string, body UpdateUserByUuidJSONRequestBody) (*updateUserByUuidResponse, error) {
	rsp, err := c.UpdateUserByUuid(ctx, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserByUuidResponse(rsp)
}

// ListPersistentVolumesWithResponse request returning *ListPersistentVolumesResponse
func (c *ClientWithResponses) ListPersistentVolumesWithResponse(ctx context.Context, params *ListPersistentVolumesParams) (*listPersistentVolumesResponse, error) {
	rsp, err := c.ListPersistentVolumes(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListPersistentVolumesResponse(rsp)
}

// ListClusterDatabaseVolumesWithResponse request returning *ListClusterDatabaseVolumesResponse
func (c *ClientWithResponses) ListClusterDatabaseVolumesWithResponse(ctx context.Context, clusterUuid string) (*listClusterDatabaseVolumesResponse, error) {
	rsp, err := c.ListClusterDatabaseVolumes(ctx, clusterUuid)
	if err != nil {
		return nil, err
	}
	return ParseListClusterDatabaseVolumesResponse(rsp)
}

// ListImagesWithResponse request returning *ListImagesResponse
func (c *ClientWithResponses) ListImagesWithResponse(ctx context.Context) (*listImagesResponse, error) {
	rsp, err := c.ListImages(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListImagesResponse(rsp)
}

// GetImageByUuidWithResponse request returning *GetImageByUuidResponse
func (c *ClientWithResponses) GetImageByUuidWithResponse(ctx context.Context, uuid string) (*getImageByUuidResponse, error) {
	rsp, err := c.GetImageByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseGetImageByUuidResponse(rsp)
}

// ListOfferingsWithResponse request returning *ListOfferingsResponse
func (c *ClientWithResponses) ListOfferingsWithResponse(ctx context.Context) (*listOfferingsResponse, error) {
	rsp, err := c.ListOfferings(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListOfferingsResponse(rsp)
}

// GetOfferingByUuidWithResponse request returning *GetOfferingByUuidResponse
func (c *ClientWithResponses) GetOfferingByUuidWithResponse(ctx context.Context, uuid string) (*getOfferingByUuidResponse, error) {
	rsp, err := c.GetOfferingByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return ParseGetOfferingByUuidResponse(rsp)
}

// ListWorkNodesWithResponse request returning *ListWorkNodesResponse
func (c *ClientWithResponses) ListWorkNodesWithResponse(ctx context.Context, params *ListWorkNodesParams) (*listWorkNodesResponse, error) {
	rsp, err := c.ListWorkNodes(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListWorkNodesResponse(rsp)
}

// DrainNodeByNodeNameWithResponse request returning *DrainNodeByNodeNameResponse
func (c *ClientWithResponses) DrainNodeByNodeNameWithResponse(ctx context.Context, nodeName string) (*drainNodeByNodeNameResponse, error) {
	rsp, err := c.DrainNodeByNodeName(ctx, nodeName)
	if err != nil {
		return nil, err
	}
	return ParseDrainNodeByNodeNameResponse(rsp)
}

// GetNodeResourceWithResponse request returning *GetNodeResourceResponse
func (c *ClientWithResponses) GetNodeResourceWithResponse(ctx context.Context, nodeName string) (*getNodeResourceResponse, error) {
	rsp, err := c.GetNodeResource(ctx, nodeName)
	if err != nil {
		return nil, err
	}
	return ParseGetNodeResourceResponse(rsp)
}

// UncordonNodeByNodeNameWithResponse request returning *UncordonNodeByNodeNameResponse
func (c *ClientWithResponses) UncordonNodeByNodeNameWithResponse(ctx context.Context, nodeName string) (*uncordonNodeByNodeNameResponse, error) {
	rsp, err := c.UncordonNodeByNodeName(ctx, nodeName)
	if err != nil {
		return nil, err
	}
	return ParseUncordonNodeByNodeNameResponse(rsp)
}

// ListBackupsWithResponse request returning *ListBackupsResponse
func (c *ClientWithResponses) ListBackupsWithResponse(ctx context.Context, clusterType ClusterType) (*listBackupsResponse, error) {
	rsp, err := c.ListBackups(ctx, clusterType)
	if err != nil {
		return nil, err
	}
	return ParseListBackupsResponse(rsp)
}

// DeleteBackupSetByUuidWithResponse request returning *DeleteBackupSetByUuidResponse
func (c *ClientWithResponses) DeleteBackupSetByUuidWithResponse(ctx context.Context, clusterType ClusterType, uuid string) (*deleteBackupSetByUuidResponse, error) {
	rsp, err := c.DeleteBackupSetByUuid(ctx, clusterType, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackupSetByUuidResponse(rsp)
}

// ListClusterBackupSetsWithResponse request returning *ListClusterBackupSetsResponse
func (c *ClientWithResponses) ListClusterBackupSetsWithResponse(ctx context.Context, clusterType ClusterType, params *ListClusterBackupSetsParams) (*listClusterBackupSetsResponse, error) {
	rsp, err := c.ListClusterBackupSets(ctx, clusterType, params)
	if err != nil {
		return nil, err
	}
	return ParseListClusterBackupSetsResponse(rsp)
}

// GetBackupsByClusterUuidWithResponse request returning *GetBackupsByClusterUuidResponse
func (c *ClientWithResponses) GetBackupsByClusterUuidWithResponse(ctx context.Context, clusterType ClusterType, uuid string) (*getBackupsByClusterUuidResponse, error) {
	rsp, err := c.GetBackupsByClusterUuid(ctx, clusterType, uuid)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupsByClusterUuidResponse(rsp)
}

// CreateFullBackupJobWithBodyWithResponse request with arbitrary body returning *CreateFullBackupJobResponse
func (c *ClientWithResponses) CreateFullBackupJobWithBodyWithResponse(ctx context.Context, clusterType ClusterType, contentType string, body io.Reader) (*createFullBackupJobResponse, error) {
	rsp, err := c.CreateFullBackupJobWithBody(ctx, clusterType, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateFullBackupJobResponse(rsp)
}

func (c *ClientWithResponses) CreateFullBackupJobWithResponse(ctx context.Context, clusterType ClusterType, body CreateFullBackupJobJSONRequestBody) (*createFullBackupJobResponse, error) {
	rsp, err := c.CreateFullBackupJob(ctx, clusterType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateFullBackupJobResponse(rsp)
}

// CreateRestoresWithBodyWithResponse request with arbitrary body returning *CreateRestoresResponse
func (c *ClientWithResponses) CreateRestoresWithBodyWithResponse(ctx context.Context, clusterType ClusterType, contentType string, body io.Reader) (*createRestoresResponse, error) {
	rsp, err := c.CreateRestoresWithBody(ctx, clusterType, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateRestoresResponse(rsp)
}

func (c *ClientWithResponses) CreateRestoresWithResponse(ctx context.Context, clusterType ClusterType, body CreateRestoresJSONRequestBody) (*createRestoresResponse, error) {
	rsp, err := c.CreateRestores(ctx, clusterType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateRestoresResponse(rsp)
}

// ListBackupSetsWithResponse request returning *ListBackupSetsResponse
func (c *ClientWithResponses) ListBackupSetsWithResponse(ctx context.Context, clusterType ClusterType, backupUuid string, params *ListBackupSetsParams) (*listBackupSetsResponse, error) {
	rsp, err := c.ListBackupSets(ctx, clusterType, backupUuid, params)
	if err != nil {
		return nil, err
	}
	return ParseListBackupSetsResponse(rsp)
}

// GetBackupsByUuidWithResponse request returning *GetBackupsByUuidResponse
func (c *ClientWithResponses) GetBackupsByUuidWithResponse(ctx context.Context, clusterType ClusterType, uuid string) (*getBackupsByUuidResponse, error) {
	rsp, err := c.GetBackupsByUuid(ctx, clusterType, uuid)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupsByUuidResponse(rsp)
}

// UpdateBackupByUuidWithBodyWithResponse request with arbitrary body returning *UpdateBackupByUuidResponse
func (c *ClientWithResponses) UpdateBackupByUuidWithBodyWithResponse(ctx context.Context, clusterType ClusterType, uuid string, contentType string, body io.Reader) (*updateBackupByUuidResponse, error) {
	rsp, err := c.UpdateBackupByUuidWithBody(ctx, clusterType, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBackupByUuidResponse(rsp)
}

func (c *ClientWithResponses) UpdateBackupByUuidWithResponse(ctx context.Context, clusterType ClusterType, uuid string, body UpdateBackupByUuidJSONRequestBody) (*updateBackupByUuidResponse, error) {
	rsp, err := c.UpdateBackupByUuid(ctx, clusterType, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBackupByUuidResponse(rsp)
}

// ListDatabaseAccountWithResponse request returning *ListDatabaseAccountResponse
func (c *ClientWithResponses) ListDatabaseAccountWithResponse(ctx context.Context, clusterType ClusterType, clusterUuid string) (*listDatabaseAccountResponse, error) {
	rsp, err := c.ListDatabaseAccount(ctx, clusterType, clusterUuid)
	if err != nil {
		return nil, err
	}
	return ParseListDatabaseAccountResponse(rsp)
}

// CreateDatabaseAccountWithBodyWithResponse request with arbitrary body returning *CreateDatabaseAccountResponse
func (c *ClientWithResponses) CreateDatabaseAccountWithBodyWithResponse(ctx context.Context, clusterType ClusterType, clusterUuid string, contentType string, body io.Reader) (*createDatabaseAccountResponse, error) {
	rsp, err := c.CreateDatabaseAccountWithBody(ctx, clusterType, clusterUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseAccountWithResponse(ctx context.Context, clusterType ClusterType, clusterUuid string, body CreateDatabaseAccountJSONRequestBody) (*createDatabaseAccountResponse, error) {
	rsp, err := c.CreateDatabaseAccount(ctx, clusterType, clusterUuid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseAccountResponse(rsp)
}

// DeleteDatabaseAccountByUuidWithResponse request returning *DeleteDatabaseAccountByUuidResponse
func (c *ClientWithResponses) DeleteDatabaseAccountByUuidWithResponse(ctx context.Context, clusterType ClusterType, clusterUuid string, uuid string) (*deleteDatabaseAccountByUuidResponse, error) {
	rsp, err := c.DeleteDatabaseAccountByUuid(ctx, clusterType, clusterUuid, uuid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatabaseAccountByUuidResponse(rsp)
}

// UpdateDatabaseAccountWithBodyWithResponse request with arbitrary body returning *UpdateDatabaseAccountResponse
func (c *ClientWithResponses) UpdateDatabaseAccountWithBodyWithResponse(ctx context.Context, clusterType ClusterType, clusterUuid string, uuid string, contentType string, body io.Reader) (*updateDatabaseAccountResponse, error) {
	rsp, err := c.UpdateDatabaseAccountWithBody(ctx, clusterType, clusterUuid, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatabaseAccountWithResponse(ctx context.Context, clusterType ClusterType, clusterUuid string, uuid string, body UpdateDatabaseAccountJSONRequestBody) (*updateDatabaseAccountResponse, error) {
	rsp, err := c.UpdateDatabaseAccount(ctx, clusterType, clusterUuid, uuid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseAccountResponse(rsp)
}

// ListClusterDatabaseInstancesWithResponse request returning *ListClusterDatabaseInstancesResponse
func (c *ClientWithResponses) ListClusterDatabaseInstancesWithResponse(ctx context.Context, clusterType ClusterType, clusterUuid string) (*listClusterDatabaseInstancesResponse, error) {
	rsp, err := c.ListClusterDatabaseInstances(ctx, clusterType, clusterUuid)
	if err != nil {
		return nil, err
	}
	return ParseListClusterDatabaseInstancesResponse(rsp)
}

// GetDatabaseInstacneByUuidWithResponse request returning *GetDatabaseInstacneByUuidResponse
func (c *ClientWithResponses) GetDatabaseInstacneByUuidWithResponse(ctx context.Context, clusterType ClusterType, uuid string) (*getDatabaseInstacneByUuidResponse, error) {
	rsp, err := c.GetDatabaseInstacneByUuid(ctx, clusterType, uuid)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseInstacneByUuidResponse(rsp)
}

// ForbidInstanceWithResponse request returning *ForbidInstanceResponse
func (c *ClientWithResponses) ForbidInstanceWithResponse(ctx context.Context, engine string, uuid string) (*forbidInstanceResponse, error) {
	rsp, err := c.ForbidInstance(ctx, engine, uuid)
	if err != nil {
		return nil, err
	}
	return ParseForbidInstanceResponse(rsp)
}

// ParseListStorageInterfaceResponse parses an HTTP response from a ListStorageInterfaceWithResponse call
func ParseListStorageInterfaceResponse(rsp *http.Response) (*listStorageInterfaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listStorageInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]BackupStorageInterface `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateStorageInterfaceResponse parses an HTTP response from a CreateStorageInterfaceWithResponse call
func ParseCreateStorageInterfaceResponse(rsp *http.Response) (*createStorageInterfaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createStorageInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *BackupStorageInterface `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteBackupByUuidResponse parses an HTTP response from a DeleteBackupByUuidWithResponse call
func ParseDeleteBackupByUuidResponse(rsp *http.Response) (*deleteBackupByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteBackupByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		response.JSON204 = &Response{}
		if err := json.Unmarshal(bodyBytes, response.JSON204); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetStorageInterfaceByUuidResponse parses an HTTP response from a GetStorageInterfaceByUuidWithResponse call
func ParseGetStorageInterfaceByUuidResponse(rsp *http.Response) (*getStorageInterfaceByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getStorageInterfaceByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *BackupStorageInterface `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetStorageInterfaceStatusByUuidResponse parses an HTTP response from a GetStorageInterfaceStatusByUuidWithResponse call
func ParseGetStorageInterfaceStatusByUuidResponse(rsp *http.Response) (*getStorageInterfaceStatusByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getStorageInterfaceStatusByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *BackupStorageInterfaceStatus `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListClusterWhitelistResponse parses an HTTP response from a ListClusterWhitelistWithResponse call
func ParseListClusterWhitelistResponse(rsp *http.Response) (*listClusterWhitelistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listClusterWhitelistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *WhiteListPage `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateClusterWhitelistResponse parses an HTTP response from a CreateClusterWhitelistWithResponse call
func ParseCreateClusterWhitelistResponse(rsp *http.Response) (*createClusterWhitelistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createClusterWhitelistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteClusterWhitelistResponse parses an HTTP response from a DeleteClusterWhitelistWithResponse call
func ParseDeleteClusterWhitelistResponse(rsp *http.Response) (*deleteClusterWhitelistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteClusterWhitelistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Response{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateClusterWhitelistResponse parses an HTTP response from a UpdateClusterWhitelistWithResponse call
func ParseUpdateClusterWhitelistResponse(rsp *http.Response) (*updateClusterWhitelistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateClusterWhitelistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateContainerShellResponse parses an HTTP response from a CreateContainerShellWithResponse call
func ParseCreateContainerShellResponse(rsp *http.Response) (*createContainerShellResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createContainerShellResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseListDatabaseTargetResponse parses an HTTP response from a ListDatabaseTargetWithResponse call
func ParseListDatabaseTargetResponse(rsp *http.Response) (*listDatabaseTargetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listDatabaseTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/Page)
				Page
				// Embedded fields due to inline allOf schema
				Items *[]DatabaseTarget `json:"items,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateDatabaseTargetResponse parses an HTTP response from a CreateDatabaseTargetWithResponse call
func ParseCreateDatabaseTargetResponse(rsp *http.Response) (*createDatabaseTargetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createDatabaseTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *DatabaseTarget `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseValidateMonitorUserPrivilegeResponse parses an HTTP response from a ValidateMonitorUserPrivilegeWithResponse call
func ParseValidateMonitorUserPrivilegeResponse(rsp *http.Response) (*validateMonitorUserPrivilegeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &validateMonitorUserPrivilegeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *DatabasePrivilegeValidation `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteDatabaseTargetByUuidResponse parses an HTTP response from a DeleteDatabaseTargetByUuidWithResponse call
func ParseDeleteDatabaseTargetByUuidResponse(rsp *http.Response) (*deleteDatabaseTargetByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteDatabaseTargetByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		response.JSON204 = &Response{}
		if err := json.Unmarshal(bodyBytes, response.JSON204); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetDatabaseTargetByUuidResponse parses an HTTP response from a GetDatabaseTargetByUuidWithResponse call
func ParseGetDatabaseTargetByUuidResponse(rsp *http.Response) (*getDatabaseTargetByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getDatabaseTargetByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *DatabaseTarget `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateDatabaseTargetByUuidResponse parses an HTTP response from a UpdateDatabaseTargetByUuidWithResponse call
func ParseUpdateDatabaseTargetByUuidResponse(rsp *http.Response) (*updateDatabaseTargetByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateDatabaseTargetByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *DatabaseTarget `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetDatetimeResponse parses an HTTP response from a GetDatetimeWithResponse call
func ParseGetDatetimeResponse(rsp *http.Response) (*getDatetimeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getDatetimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *string `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateDatetimeResponse parses an HTTP response from a UpdateDatetimeWithResponse call
func ParseUpdateDatetimeResponse(rsp *http.Response) (*updateDatetimeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateDatetimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *string `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateEventResponse parses an HTTP response from a CreateEventWithResponse call
func ParseCreateEventResponse(rsp *http.Response) (*createEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListEventPageResponse parses an HTTP response from a ListEventPageWithResponse call
func ParseListEventPageResponse(rsp *http.Response) (*listEventPageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listEventPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/Page)
				Page
				// Embedded fields due to inline allOf schema
				Items *[]Event `json:"items,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListNetworkResponse parses an HTTP response from a ListNetworkWithResponse call
func ParseListNetworkResponse(rsp *http.Response) (*listNetworkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				Items *[]Network `json:"items,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateNetworkResponse parses an HTTP response from a CreateNetworkWithResponse call
func ParseCreateNetworkResponse(rsp *http.Response) (*createNetworkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *Network `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleleNetworkAddressByUuidResponse parses an HTTP response from a DeleleNetworkAddressByUuidWithResponse call
func ParseDeleleNetworkAddressByUuidResponse(rsp *http.Response) (*deleleNetworkAddressByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleleNetworkAddressByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteNewtorkByUuidResponse parses an HTTP response from a DeleteNewtorkByUuidWithResponse call
func ParseDeleteNewtorkByUuidResponse(rsp *http.Response) (*deleteNewtorkByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteNewtorkByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateNetworkAddressResponse parses an HTTP response from a CreateNetworkAddressWithResponse call
func ParseCreateNetworkAddressResponse(rsp *http.Response) (*createNetworkAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createNetworkAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *NetworkAddress `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateVIPValiationResponse parses an HTTP response from a CreateVIPValiationWithResponse call
func ParseCreateVIPValiationResponse(rsp *http.Response) (*createVIPValiationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createVIPValiationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				Ok     *bool   `json:"ok,omitempty"`
				Reason *string `json:"reason,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetK8sResourceOverviewResponse parses an HTTP response from a GetK8sResourceOverviewWithResponse call
func ParseGetK8sResourceOverviewResponse(rsp *http.Response) (*getK8sResourceOverviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getK8sResourceOverviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *K8sResourceOverview `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetLicenseResponse parses an HTTP response from a GetLicenseWithResponse call
func ParseGetLicenseResponse(rsp *http.Response) (*getLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *LicenseInfo `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		response.JSON201 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *string `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON201); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateLicenseResponse parses an HTTP response from a UpdateLicenseWithResponse call
func ParseUpdateLicenseResponse(rsp *http.Response) (*updateLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseLoginUserResponse parses an HTTP response from a LoginUserWithResponse call
func ParseLoginUserResponse(rsp *http.Response) (*loginUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &loginUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *User `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMySQLAggregatedSlowQueryLogResponse parses an HTTP response from a ListMySQLAggregatedSlowQueryLogWithResponse call
func ParseListMySQLAggregatedSlowQueryLogResponse(rsp *http.Response) (*listMySQLAggregatedSlowQueryLogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMySQLAggregatedSlowQueryLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/Page)
				Page
				// Embedded fields due to inline allOf schema
				Items *[]AggregatedSlowQueryLog `json:"items,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMySQLErrorLogResponse parses an HTTP response from a ListMySQLErrorLogWithResponse call
func ParseListMySQLErrorLogResponse(rsp *http.Response) (*listMySQLErrorLogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMySQLErrorLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/Page)
				Page
				// Embedded fields due to inline allOf schema
				Items *[]MySQLErrorLog `json:"items,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMySQLSlowQueryLogResponse parses an HTTP response from a ListMySQLSlowQueryLogWithResponse call
func ParseListMySQLSlowQueryLogResponse(rsp *http.Response) (*listMySQLSlowQueryLogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMySQLSlowQueryLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/Page)
				Page
				// Embedded fields due to inline allOf schema
				Items *[]SlowQueryLog `json:"items,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMssqlClsutersResponse parses an HTTP response from a ListMssqlClsutersWithResponse call
func ParseListMssqlClsutersResponse(rsp *http.Response) (*listMssqlClsutersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMssqlClsutersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]MssqlClusterOverview `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateMssqlClusterResponse parses an HTTP response from a CreateMssqlClusterWithResponse call
func ParseCreateMssqlClusterResponse(rsp *http.Response) (*createMssqlClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createMssqlClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMssqlSchemaResponse parses an HTTP response from a ListMssqlSchemaWithResponse call
func ParseListMssqlSchemaResponse(rsp *http.Response) (*listMssqlSchemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMssqlSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]DatabaseSchema `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateMssqlSchemaResponse parses an HTTP response from a CreateMssqlSchemaWithResponse call
func ParseCreateMssqlSchemaResponse(rsp *http.Response) (*createMssqlSchemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createMssqlSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteMssqlSchemaByUuidResponse parses an HTTP response from a DeleteMssqlSchemaByUuidWithResponse call
func ParseDeleteMssqlSchemaByUuidResponse(rsp *http.Response) (*deleteMssqlSchemaByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteMssqlSchemaByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteMssqlClusterByUuidResponse parses an HTTP response from a DeleteMssqlClusterByUuidWithResponse call
func ParseDeleteMssqlClusterByUuidResponse(rsp *http.Response) (*deleteMssqlClusterByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteMssqlClusterByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetMssqlClusterResponse parses an HTTP response from a GetMssqlClusterWithResponse call
func ParseGetMssqlClusterResponse(rsp *http.Response) (*getMssqlClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getMssqlClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]MssqlClusterOverview `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateMssqlClusterByUuidResponse parses an HTTP response from a UpdateMssqlClusterByUuidWithResponse call
func ParseUpdateMssqlClusterByUuidResponse(rsp *http.Response) (*updateMssqlClusterByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateMssqlClusterByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMysqlClusterResponse parses an HTTP response from a ListMysqlClusterWithResponse call
func ParseListMysqlClusterResponse(rsp *http.Response) (*listMysqlClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMysqlClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]MysqlClusterOverview `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateMysqlClusterResponse parses an HTTP response from a CreateMysqlClusterWithResponse call
func ParseCreateMysqlClusterResponse(rsp *http.Response) (*createMysqlClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createMysqlClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMysqlClusterConfigResponse parses an HTTP response from a ListMysqlClusterConfigWithResponse call
func ParseListMysqlClusterConfigResponse(rsp *http.Response) (*listMysqlClusterConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMysqlClusterConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]MysqlClusterConfig `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateMysqlClusterConfigResponse parses an HTTP response from a UpdateMysqlClusterConfigWithResponse call
func ParseUpdateMysqlClusterConfigResponse(rsp *http.Response) (*updateMysqlClusterConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateMysqlClusterConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMysqlDatabaseSchemasResponse parses an HTTP response from a ListMysqlDatabaseSchemasWithResponse call
func ParseListMysqlDatabaseSchemasResponse(rsp *http.Response) (*listMysqlDatabaseSchemasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMysqlDatabaseSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]DatabaseSchema `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateMysqlSchemaResponse parses an HTTP response from a CreateMysqlSchemaWithResponse call
func ParseCreateMysqlSchemaResponse(rsp *http.Response) (*createMysqlSchemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createMysqlSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *DatabaseSchema `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteMysqlSchemaByUuuidResponse parses an HTTP response from a DeleteMysqlSchemaByUuuidWithResponse call
func ParseDeleteMysqlSchemaByUuuidResponse(rsp *http.Response) (*deleteMysqlSchemaByUuuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteMysqlSchemaByUuuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetMysqlDatabaseTopologyResponse parses an HTTP response from a GetMysqlDatabaseTopologyWithResponse call
func ParseGetMysqlDatabaseTopologyResponse(rsp *http.Response) (*getMysqlDatabaseTopologyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getMysqlDatabaseTopologyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *MysqlClusterTopology `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteMysqlClsuterByUuidResponse parses an HTTP response from a DeleteMysqlClsuterByUuidWithResponse call
func ParseDeleteMysqlClsuterByUuidResponse(rsp *http.Response) (*deleteMysqlClsuterByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteMysqlClsuterByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetClusterByUuidResponse parses an HTTP response from a GetClusterByUuidWithResponse call
func ParseGetClusterByUuidResponse(rsp *http.Response) (*getClusterByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getClusterByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]MysqlClusterOverview `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateClusterByUuidResponse parses an HTTP response from a UpdateClusterByUuidWithResponse call
func ParseUpdateClusterByUuidResponse(rsp *http.Response) (*updateClusterByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateClusterByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMysqlConfigResponse parses an HTTP response from a ListMysqlConfigWithResponse call
func ParseListMysqlConfigResponse(rsp *http.Response) (*listMysqlConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMysqlConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]MysqlDatabaseConfig `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateMysqlConfigResponse parses an HTTP response from a CreateMysqlConfigWithResponse call
func ParseCreateMysqlConfigResponse(rsp *http.Response) (*createMysqlConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createMysqlConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteMysqlConfigByUuidResponse parses an HTTP response from a DeleteMysqlConfigByUuidWithResponse call
func ParseDeleteMysqlConfigByUuidResponse(rsp *http.Response) (*deleteMysqlConfigByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteMysqlConfigByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		response.JSON204 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON204); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateMysqlConfigByUuidResponse parses an HTTP response from a UpdateMysqlConfigByUuidWithResponse call
func ParseUpdateMysqlConfigByUuidResponse(rsp *http.Response) (*updateMysqlConfigByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateMysqlConfigByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateRecreatedInstanceResponse parses an HTTP response from a CreateRecreatedInstanceWithResponse call
func ParseCreateRecreatedInstanceResponse(rsp *http.Response) (*createRecreatedInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createRecreatedInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMySQLAuditLogResponse parses an HTTP response from a ListMySQLAuditLogWithResponse call
func ParseListMySQLAuditLogResponse(rsp *http.Response) (*listMySQLAuditLogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMySQLAuditLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/Page)
				Page
				// Embedded fields due to inline allOf schema
				Items *[]MySQLAuditLog `json:"items,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMySQLSwitchMasterLogResponse parses an HTTP response from a ListMySQLSwitchMasterLogWithResponse call
func ParseListMySQLSwitchMasterLogResponse(rsp *http.Response) (*listMySQLSwitchMasterLogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMySQLSwitchMasterLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/Page)
				Page
				// Embedded fields due to inline allOf schema
				Items *[]MySQLSwitchMasterLog `json:"items,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMysqlProxyResponse parses an HTTP response from a ListMysqlProxyWithResponse call
func ParseListMysqlProxyResponse(rsp *http.Response) (*listMysqlProxyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMysqlProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]MysqlProxy `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateMysqlProxyResponse parses an HTTP response from a CreateMysqlProxyWithResponse call
func ParseCreateMysqlProxyResponse(rsp *http.Response) (*createMysqlProxyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createMysqlProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteMysqlProxyByUuidResponse parses an HTTP response from a DeleteMysqlProxyByUuidWithResponse call
func ParseDeleteMysqlProxyByUuidResponse(rsp *http.Response) (*deleteMysqlProxyByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteMysqlProxyByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		response.JSON204 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON204); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMysqlProxyBuClusterResponse parses an HTTP response from a ListMysqlProxyBuClusterWithResponse call
func ParseListMysqlProxyBuClusterResponse(rsp *http.Response) (*listMysqlProxyBuClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMysqlProxyBuClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]MysqlProxy `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateMySQLProxyByUuidResponse parses an HTTP response from a UpdateMySQLProxyByUuidWithResponse call
func ParseUpdateMySQLProxyByUuidResponse(rsp *http.Response) (*updateMySQLProxyByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateMySQLProxyByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListMysqlProxyAccountsResponse parses an HTTP response from a ListMysqlProxyAccountsWithResponse call
func ParseListMysqlProxyAccountsResponse(rsp *http.Response) (*listMysqlProxyAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listMysqlProxyAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]DatabaseAccount `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateMysqlProxyAccountResponse parses an HTTP response from a CreateMysqlProxyAccountWithResponse call
func ParseCreateMysqlProxyAccountResponse(rsp *http.Response) (*createMysqlProxyAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createMysqlProxyAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateMysqlProxyAccountResponse parses an HTTP response from a UpdateMysqlProxyAccountWithResponse call
func ParseUpdateMysqlProxyAccountResponse(rsp *http.Response) (*updateMysqlProxyAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateMysqlProxyAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteMyqlProxyAccountResponse parses an HTTP response from a DeleteMyqlProxyAccountWithResponse call
func ParseDeleteMyqlProxyAccountResponse(rsp *http.Response) (*deleteMyqlProxyAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteMyqlProxyAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		response.JSON204 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON204); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetMysqlSlowQueryLogResponse parses an HTTP response from a GetMysqlSlowQueryLogWithResponse call
func ParseGetMysqlSlowQueryLogResponse(rsp *http.Response) (*getMysqlSlowQueryLogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getMysqlSlowQueryLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]MysqlSlowQueryLog `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListNamespacesResponse parses an HTTP response from a ListNamespacesWithResponse call
func ParseListNamespacesResponse(rsp *http.Response) (*listNamespacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]Namespace `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListOracleClusterResponse parses an HTTP response from a ListOracleClusterWithResponse call
func ParseListOracleClusterResponse(rsp *http.Response) (*listOracleClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listOracleClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]OracleClusterOverview `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateOracleClusterResponse parses an HTTP response from a CreateOracleClusterWithResponse call
func ParseCreateOracleClusterResponse(rsp *http.Response) (*createOracleClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createOracleClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateOracleAccountResponse parses an HTTP response from a UpdateOracleAccountWithResponse call
func ParseUpdateOracleAccountResponse(rsp *http.Response) (*updateOracleAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateOracleAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListOracleSchemasResponse parses an HTTP response from a ListOracleSchemasWithResponse call
func ParseListOracleSchemasResponse(rsp *http.Response) (*listOracleSchemasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listOracleSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]OracleSchema `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteOracleClusterByUuidResponse parses an HTTP response from a DeleteOracleClusterByUuidWithResponse call
func ParseDeleteOracleClusterByUuidResponse(rsp *http.Response) (*deleteOracleClusterByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteOracleClusterByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		response.JSON204 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON204); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetOracleClusterByUuiResponse parses an HTTP response from a GetOracleClusterByUuiWithResponse call
func ParseGetOracleClusterByUuiResponse(rsp *http.Response) (*getOracleClusterByUuiResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getOracleClusterByUuiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]OracleClusterOverview `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateOracleClusterByUuidResponse parses an HTTP response from a UpdateOracleClusterByUuidWithResponse call
func ParseUpdateOracleClusterByUuidResponse(rsp *http.Response) (*updateOracleClusterByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateOracleClusterByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListOracleAccountResponse parses an HTTP response from a ListOracleAccountWithResponse call
func ParseListOracleAccountResponse(rsp *http.Response) (*listOracleAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listOracleAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]OracleAccount `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetClusterOverviewResponse parses an HTTP response from a GetClusterOverviewWithResponse call
func ParseGetClusterOverviewResponse(rsp *http.Response) (*getClusterOverviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getClusterOverviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *ClusterResourceOverview `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateDepartmentReportResponse parses an HTTP response from a CreateDepartmentReportWithResponse call
func ParseCreateDepartmentReportResponse(rsp *http.Response) (*createDepartmentReportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createDepartmentReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateSystemReportResponse parses an HTTP response from a CreateSystemReportWithResponse call
func ParseCreateSystemReportResponse(rsp *http.Response) (*createSystemReportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createSystemReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListStorageClassesResponse parses an HTTP response from a ListStorageClassesWithResponse call
func ParseListStorageClassesResponse(rsp *http.Response) (*listStorageClassesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listStorageClassesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]StorageClass `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParsePutApiV1TagClusterUuidResponse parses an HTTP response from a PutApiV1TagClusterUuidWithResponse call
func ParsePutApiV1TagClusterUuidResponse(rsp *http.Response) (*putApiV1TagClusterUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &putApiV1TagClusterUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*listUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]UserList `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*createUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteUserByUuidResponse parses an HTTP response from a DeleteUserByUuidWithResponse call
func ParseDeleteUserByUuidResponse(rsp *http.Response) (*deleteUserByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteUserByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		response.JSON204 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON204); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateUserByUuidResponse parses an HTTP response from a UpdateUserByUuidWithResponse call
func ParseUpdateUserByUuidResponse(rsp *http.Response) (*updateUserByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateUserByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListPersistentVolumesResponse parses an HTTP response from a ListPersistentVolumesWithResponse call
func ParseListPersistentVolumesResponse(rsp *http.Response) (*listPersistentVolumesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listPersistentVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/Page)
				Page
				// Embedded struct due to allOf(#/components/schemas/StorageClass)
				StorageClass
				// Embedded fields due to inline allOf schema
				Items *[]PersistentVolume `json:"items,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListClusterDatabaseVolumesResponse parses an HTTP response from a ListClusterDatabaseVolumesWithResponse call
func ParseListClusterDatabaseVolumesResponse(rsp *http.Response) (*listClusterDatabaseVolumesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listClusterDatabaseVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]DatabaseVolume `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListImagesResponse parses an HTTP response from a ListImagesWithResponse call
func ParseListImagesResponse(rsp *http.Response) (*listImagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]Image `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetImageByUuidResponse parses an HTTP response from a GetImageByUuidWithResponse call
func ParseGetImageByUuidResponse(rsp *http.Response) (*getImageByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getImageByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *Image `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListOfferingsResponse parses an HTTP response from a ListOfferingsWithResponse call
func ParseListOfferingsResponse(rsp *http.Response) (*listOfferingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listOfferingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]Offering `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetOfferingByUuidResponse parses an HTTP response from a GetOfferingByUuidWithResponse call
func ParseGetOfferingByUuidResponse(rsp *http.Response) (*getOfferingByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getOfferingByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *Offering `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListWorkNodesResponse parses an HTTP response from a ListWorkNodesWithResponse call
func ParseListWorkNodesResponse(rsp *http.Response) (*listWorkNodesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listWorkNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]WorkNode `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDrainNodeByNodeNameResponse parses an HTTP response from a DrainNodeByNodeNameWithResponse call
func ParseDrainNodeByNodeNameResponse(rsp *http.Response) (*drainNodeByNodeNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &drainNodeByNodeNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *string `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetNodeResourceResponse parses an HTTP response from a GetNodeResourceWithResponse call
func ParseGetNodeResourceResponse(rsp *http.Response) (*getNodeResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getNodeResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *WorkNodeResource `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUncordonNodeByNodeNameResponse parses an HTTP response from a UncordonNodeByNodeNameWithResponse call
func ParseUncordonNodeByNodeNameResponse(rsp *http.Response) (*uncordonNodeByNodeNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &uncordonNodeByNodeNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *string `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListBackupsResponse parses an HTTP response from a ListBackupsWithResponse call
func ParseListBackupsResponse(rsp *http.Response) (*listBackupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]Backup `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteBackupSetByUuidResponse parses an HTTP response from a DeleteBackupSetByUuidWithResponse call
func ParseDeleteBackupSetByUuidResponse(rsp *http.Response) (*deleteBackupSetByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteBackupSetByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Response{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListClusterBackupSetsResponse parses an HTTP response from a ListClusterBackupSetsWithResponse call
func ParseListClusterBackupSetsResponse(rsp *http.Response) (*listClusterBackupSetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listClusterBackupSetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *struct {
				// Embedded struct due to allOf(#/components/schemas/Page)
				Page
				// Embedded fields due to inline allOf schema
				Items *[]BackupSet `json:"items,omitempty"`
			} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetBackupsByClusterUuidResponse parses an HTTP response from a GetBackupsByClusterUuidWithResponse call
func ParseGetBackupsByClusterUuidResponse(rsp *http.Response) (*getBackupsByClusterUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getBackupsByClusterUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *Backup `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateFullBackupJobResponse parses an HTTP response from a CreateFullBackupJobWithResponse call
func ParseCreateFullBackupJobResponse(rsp *http.Response) (*createFullBackupJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createFullBackupJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateRestoresResponse parses an HTTP response from a CreateRestoresWithResponse call
func ParseCreateRestoresResponse(rsp *http.Response) (*createRestoresResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createRestoresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *DatabaseRestoreRequest `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListBackupSetsResponse parses an HTTP response from a ListBackupSetsWithResponse call
func ParseListBackupSetsResponse(rsp *http.Response) (*listBackupSetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listBackupSetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]BackupSet `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetBackupsByUuidResponse parses an HTTP response from a GetBackupsByUuidWithResponse call
func ParseGetBackupsByUuidResponse(rsp *http.Response) (*getBackupsByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getBackupsByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *Backup `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateBackupByUuidResponse parses an HTTP response from a UpdateBackupByUuidWithResponse call
func ParseUpdateBackupByUuidResponse(rsp *http.Response) (*updateBackupByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateBackupByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *Backup `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListDatabaseAccountResponse parses an HTTP response from a ListDatabaseAccountWithResponse call
func ParseListDatabaseAccountResponse(rsp *http.Response) (*listDatabaseAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listDatabaseAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]DatabaseAccount `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseCreateDatabaseAccountResponse parses an HTTP response from a CreateDatabaseAccountWithResponse call
func ParseCreateDatabaseAccountResponse(rsp *http.Response) (*createDatabaseAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createDatabaseAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseDeleteDatabaseAccountByUuidResponse parses an HTTP response from a DeleteDatabaseAccountByUuidWithResponse call
func ParseDeleteDatabaseAccountByUuidResponse(rsp *http.Response) (*deleteDatabaseAccountByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteDatabaseAccountByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseUpdateDatabaseAccountResponse parses an HTTP response from a UpdateDatabaseAccountWithResponse call
func ParseUpdateDatabaseAccountResponse(rsp *http.Response) (*updateDatabaseAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateDatabaseAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseListClusterDatabaseInstancesResponse parses an HTTP response from a ListClusterDatabaseInstancesWithResponse call
func ParseListClusterDatabaseInstancesResponse(rsp *http.Response) (*listClusterDatabaseInstancesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &listClusterDatabaseInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *[]DatabaseInstanceDetail `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseGetDatabaseInstacneByUuidResponse parses an HTTP response from a GetDatabaseInstacneByUuidWithResponse call
func ParseGetDatabaseInstacneByUuidResponse(rsp *http.Response) (*getDatabaseInstacneByUuidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getDatabaseInstacneByUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *DatabaseInstance `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	}

	return response, nil
}

// ParseForbidInstanceResponse parses an HTTP response from a ForbidInstanceWithResponse call
func ParseForbidInstanceResponse(rsp *http.Response) (*forbidInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &forbidInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			// Embedded struct due to allOf(#/components/schemas/Response)
			Response
			// Embedded fields due to inline allOf schema
			Data *map[string]interface{} `json:"data,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		response.JSONDefault = &Error{}
		if err := json.Unmarshal(bodyBytes, response.JSONDefault); err != nil {
			return nil, err
		}

	}

	return response, nil
}
